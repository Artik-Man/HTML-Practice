<!DOCTYPE html><!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="apple-touch-icon" sizes="180x180" href="./assets/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./assets/icons/favicon-16x16.png">
    <link rel="manifest" href="./assets/icons/site.webmanifest">
    <link rel="mask-icon" href="./assets/icons/favicon.svg" color="#5bbad5">
    <link rel="shortcut icon" href="./assets/icons/favicon.ico">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-config" content="./assets/icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <link href="https://fonts.googleapis.com/css?family=Philosopher&amp;display=swap&amp;subset=cyrillic" rel="stylesheet">
    <title>HTML Practice</title>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600&amp;display=swap&amp;subset=cyrillic" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.2/css/all.min.css">
  <link href="styles.5846590c5a56abd0e5ff.css" rel="stylesheet"></head>
  <body>
    <main>
      <div class="main-menu">
        <button id="menu-switch-button" title="Меню"></button>
        <menu id="menu"></menu>
      </div>
      <div class="main-content">
        <div class="container">
          <h1><a class="logo" href="https://artik-man.github.io/HTML-Practice/"><span class="top">HTML</span><span class="bottom">Practice</span></a></h1>
          <p></p>
        </div>
<article id="contents">
  <div class="container">
    <h2>Содержание</h2>
    <ul>
    </ul>
    <ul>
      <li>SVG</li>
      <li>Вёрстка модальных окон</li>
      <li>Вёрстка форм</li>
      <li>Градиенты, тени и фильтры</li>
      <li>Трансформации</li>
      <li>Анимации</li>
      <li>Аудио и видео</li>
      <li>Отзывчивый дизайн и медиа-выражения</li>
      <li>Поговорим о семантике</li>
      <li>Bootstrap</li>
      <li>Препроцессоры</li>
    </ul>
  </div>
</article>
<article id="introduction">
  <div class="container">
    <h2>Введение</h2>
    <p>
       Это практическое руководство создано для начинающих верстальщиков и frontend-разработчиков, которые уже успели познакомиться с множеством HTML-тегов и CSS-свойств. 
      Как минимум, вы должны быть знакомы со следующими тегами:
    </p>
    <ul class="columns-2">
      <li><a href="http://htmlbook.ru/html/a" target="_blank">A</a></li>
      <li><a href="http://htmlbook.ru/html/article" target="_blank">ARTICLE</a></li>
      <li><a href="http://htmlbook.ru/html/body" target="_blank">BODY</a></li>
      <li><a href="http://htmlbook.ru/html/button" target="_blank">BUTTON</a></li>
      <li><a href="http://htmlbook.ru/html/div" target="_blank">DIV</a></li>
      <li><a href="http://htmlbook.ru/html/h1" target="_blank">H1</a></li>
      <li><a href="http://htmlbook.ru/html/h2" target="_blank">H2</a></li>
      <li><a href="http://htmlbook.ru/html/h3" target="_blank">H3</a></li>
      <li><a href="http://htmlbook.ru/html/head" target="_blank">HEAD</a></li>
      <li><a href="http://htmlbook.ru/html/html" target="_blank">HTML</a></li>
      <li><a href="http://htmlbook.ru/html/img" target="_blank">IMG</a></li>
      <li><a href="http://htmlbook.ru/html/input" target="_blank">INPUT</a></li>
      <li><a href="http://htmlbook.ru/html/label" target="_blank">LABEL</a></li>
      <li><a href="http://htmlbook.ru/html/li" target="_blank">LI</a></li>
      <li><a href="http://htmlbook.ru/html/link" target="_blank">LINK</a></li>
      <li><a href="http://htmlbook.ru/html/p" target="_blank">P</a></li>
      <li><a href="http://htmlbook.ru/html/section" target="_blank">SECTION</a></li>
      <li><a href="http://htmlbook.ru/html/span" target="_blank">SPAN</a></li>
      <li><a href="http://htmlbook.ru/html/textarea" target="_blank">TEXTAREA</a></li>
      <li><a href="http://htmlbook.ru/html/title" target="_blank">TITLE</a></li>
      <li><a href="http://htmlbook.ru/html/ul" target="_blank">UL </a></li>
    </ul>
    <p>Было бы неплохо, если бы вы могли оперировать такими единицами измерения, как px, %, em, rem, vw, vh, vmin и vmax. <a href="https://developer.mozilla.org/ru/docs/Learn/CSS/Introduction_to_CSS/Values_and_units" target="_blank">О единицах измерения стоит почитать здесь</a>, но не волнуйтесь, с основными единицами измерения мы ознакомимся в скором времени. А перед тем, как вы приступите к этому руководству, вы должны понимать, <a href="https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Селекторы" target="_blank">как писать селекторы</a>. Для закрепления этих знаний предлагаю  <a href="https://flukeout.github.io/" target="_blank">поиграть в эту игру</a>. Кроме того, вы должны знать основные css-свойства, перечисленные в списке ниже, и другие.</p>
    <ul class="columns-2 can-print-break">
      <li><a href="http://htmlbook.ru/css/background" target="_blank">background</a></li>
      <li><a href="http://htmlbook.ru/css/border" target="_blank">border</a></li>
      <li><a href="http://htmlbook.ru/css/box-shadow" target="_blank">box-shadow</a></li>
      <li><a href="http://htmlbook.ru/css/display" target="_blank">display</a></li>
      <li><a href="http://htmlbook.ru/css/clear" target="_blank">clear</a></li>
      <li><a href="http://htmlbook.ru/css/cursor" target="_blank">cursor</a></li>
      <li><a href="http://htmlbook.ru/css/color" target="_blank">color</a></li>
      <li><a href="http://htmlbook.ru/css/column-count" target="_blank">column-count</a></li>
      <li><a href="http://htmlbook.ru/css/float" target="_blank">float</a></li>
      <li><a href="http://htmlbook.ru/css/font-family" target="_blank">font-family</a></li>
      <li><a href="http://htmlbook.ru/css/font-size" target="_blank">font-size</a></li>
      <li><a href="http://htmlbook.ru/css/font-weight" target="_blank">font-weight</a></li>
      <li><a href="http://htmlbook.ru/css/height" target="_blank">height</a></li>
      <li><a href="http://htmlbook.ru/css/justify-content" target="_blank">justify-content</a></li>
      <li><a href="http://htmlbook.ru/css/line-height" target="_blank">line-height</a></li>
      <li><a href="http://htmlbook.ru/css/list-style" target="_blank">list-style</a></li>
      <li><a href="http://htmlbook.ru/css/margin" target="_blank">margin</a></li>
      <li><a href="http://htmlbook.ru/css/max-height" target="_blank">max-height</a></li>
      <li><a href="http://htmlbook.ru/css/max-width" target="_blank">max-width</a></li>
      <li><a href="http://htmlbook.ru/css/min-height" target="_blank">min-height</a></li>
      <li><a href="http://htmlbook.ru/css/min-width" target="_blank">min-width</a></li>
      <li><a href="http://htmlbook.ru/css/opacity" target="_blank">opacity</a></li>
      <li><a href="http://htmlbook.ru/css/outline" target="_blank">outline</a></li>
      <li><a href="http://htmlbook.ru/css/overflow" target="_blank">overflow</a></li>
      <li><a href="http://htmlbook.ru/css/padding" target="_blank">padding</a></li>
      <li><a href="http://htmlbook.ru/css/position" target="_blank">position</a></li>
      <li><a href="http://htmlbook.ru/css/text-align" target="_blank">text-align</a></li>
      <li><a href="http://htmlbook.ru/css/text-decoration" target="_blank">text-decoration</a></li>
      <li><a href="http://htmlbook.ru/css/text-overflow" target="_blank">text-overflow</a></li>
      <li><a href="http://htmlbook.ru/css/text-shadow" target="_blank">text-shadow</a></li>
      <li><a href="http://htmlbook.ru/css/transform" target="_blank">transform</a></li>
      <li><a href="http://htmlbook.ru/css/transition" target="_blank">transition</a></li>
      <li><a href="http://htmlbook.ru/css/vertical-align" target="_blank">vertical-align</a></li>
      <li><a href="http://htmlbook.ru/css/visibility" target="_blank">visibility</a></li>
      <li><a href="http://htmlbook.ru/css/white-space" target="_blank">white-space</a></li>
      <li><a href="http://htmlbook.ru/css/width" target="_blank">width</a></li>
      <li><a href="http://htmlbook.ru/css/z-index" target="_blank">z-index</a></li>
    </ul>
  </div>
</article>
<article id="git">
  <div class="container">
    <h2>Кратко о GIT</h2>
    <p>
      GIT — это система контроля версий. Позволяет отслеживать и фиксировать изменения в коде, смотреть,
      как развивался проект и какие люди вкладывали в него своё время. Без базовых знаний гита работать
      frontend-разработчиком просто нельзя.
    </p>
    <h3>Установка</h3>
    <p>По этой ссылке вы найдете инструкцию по установке GIT на свой компьютер: <a href="https://git-scm.com/downloads" target="_blank">Download GIT</a></p>
    <h3>Настройка</h3>
    <p>После установки, нам нужно настроить GIT. Самое главное - выполнить команды:</p>
    <pre data-lang="bash">git config --global user.name "My Name"
git config --global user.email myEmail@example.com</pre>
    <h3>GitHub</h3>
    <p>
      Теперь нужно зарегистрироваться на GitHub или на любом другом сервисе для хостинга проектов, основанном
      на системе контроля версий GIT.
    </p>
    <p><a href="https://github.com/" target="_blank">GitHub.com</a></p>
    <p>С помощью генератора ключей нужно создать новый ключ для репозитория. Для этого воспользуйтесь командой</p>
    <pre data-lang="bash">ssh-keygen</pre>
    <p>
      Следуйте инструкциям. После создания ключей поместите их в папку C:\Users\YOUR_NAME\.ssh для
      пользователей Windows или в папку ~/.ssh для пользователей Linux или MacOS.
    </p>
    <p>
      На сайте GitHub.com добавьте публичный (id_rsa.pub) ssh-ключ. Это можно сделать в разделе настройки
      пользователя.
    </p>
    <p>
      Создайте на сайте новый проект. После создания проекта вы найдете ссылку вида
      git@github.com:YOUR_LOGIN/YOUR_PROJECT.git
    </p>
    <p>
      На своём компьютере создайте папку, где будете хранить ваши проекты. В этой папке откройте терминал
      (например, C:\projects) и выполните команду:
    </p>
    <pre data-lang="bash">git clone git@github.com:YOUR_LOGIN/YOUR_PROJECT.git</pre>
    <p>На данном этапе можно сказать, что мы настроили GIT.</p>
    <h3>Основные команды</h3>
    <p>
      Чтобы сохранить измененные файлы в каком-то состоянии, нужно их закоммитить. Для этого нужно сначала
      добавить измененные файлы в будующий коммит
    </p>
    <pre data-lang="bash">git add -A          </pre>
    <p>Далее нужно сохранить коммит</p>
    <pre data-lang="bash">git commit -m "Название коммита"          </pre>
    <p>
      Коммиты лучше всего называть так, чтобы было понятно, что было сделано в этом коммите, как именно
      изменилось приложение или сайт. Например, "Изменен цвет кнопки корзины". Еще лучше было бы, если бы мы
      написали это на английском.
    </p>
    <p>Теперь нужно отправить изменения на сервер. Для этого есть команда:</p>
    <pre data-lang="bash">git push          </pre>
    <p>Чтобы получить изменения с сервера, существует команда:</p>
    <pre data-lang="bash">git pull          </pre>
    <p>Кроме того, вам стоит изучить такие команды, как merge, status, branch, checkout, revert и многие другие.</p>
    <p>Больше подробностей читать здесь: </p>
    <ul>
      <li><a href="https://proglib.io/p/git-for-half-an-hour/" target="_blank">Git за полчаса: руководство для начинающих</a></li>
      <li><a href="https://tproger.ru/translations/git-quick-start/" target="_blank">Git. Быстрый старт по использованию основных операций с объяснениями</a></li>
      <li><a href="https://git-scm.com/book/en/v2" target="_blank">Pro GIT</a></li>
    </ul>
  </div>
</article>
<article id="units">
  <div class="container">
    <h2>Единицы измерения в CSS</h2>
    <p>
      Прежде, чем начать что-то делать, надо разобраться с принятыми единицами измерения. CSS поддерживает множество единиц измерения, но здесь будут описаны только самые часто-применяемые.</p>
    <h3>px - пиксели</h3>
    <p>
      Самая основная единица измерения, которая встречается практически везде - это пиксели. Пиксель - это точка минимального размера на вашем экране. Весь экран состоит из таких точек.
      Вообще, если мы говорим о CSS, то пиксели здесь не всегда будут равны тем самым точкам на экране. 
      К примеру, если у вас Retina Display, то, скорее всего, за один CSS-пиксель у вас будет отвечать аж квадрат из 4-х соседних пикселей. 
      Эта технология служит для сглаживания изображений. 
      Итак, пиксели. Если вам в конкретной задаче нужна постоянная, практически ни от чего не зависящая единица измерения, смело используйте её. 
    </p>
    <p>Пример - нужно установить размер контейнера для сайта. С очень высокой вероятностью, вы должны использовать пиксели. </p>
    <h3>% - проценты</h3>
    <p>Проценты используются там, где нам нужно задать величину относительно другого значения. Как правило, относительно родителя. </p>
    <p>
      К примеру, у родительского блока есть четыре равных, дочерних. Ширина родительского блока зависит от размера экрана пользователя и нам точно не известна, а дочерние блоки должны быть расположены рядом друг с другом. Используем ширину 25% у блоков и мы решим эту задачу.</p>
    <h3>em и rem - значение относительно шрифта. </h3>
    <p>
      em - это относительная единица длины, равная размеру текущего шрифта. То есть, если мы верстаем кнопку, кегль шрифта которой равен 10px, мы можем установить padding: 1.5em, что будет означать, что пока размер шрифта этой кнопки равен 10px, то padding будет равен 15px (1.5*10px).
      Если где-то ниже будет вторая такая кнопка с модификатором (дополнительный класс, который, например, переопределяет размер шрифта на 20px),
      то padding, равный 1.5em преобразуется браузером в 30px (1.5*20px).
    </p>
    <p>rem делает всё то же самое, но берёт размер шрифта, установленного в html. То есть, если мы хотим точно управлять размером шрифта, лучше установить этот код:</p>
    <pre data-lang="css">html {
  font-size: 18px;   
} </pre>
    <p>
      Так, мы сможем установить размер шрифта в rem во всём документе, а когда нам понадобится его уменьшить (например, для мобильных устройств с маленькими экранами), мы просто изменим это значение прям в html и весь сайт адаптируется под новый экран.</p>
    <h3>vw, vh, vmin и vmax - значение относительно размера экрана </h3>
    <p>Тут всё просто. Каким бы ни был экран пользователя вашего сайта, 1vw всегда будет равен 1% от ширины его экрана, а 1vh будет равен 1% от высоты его экрана.</p>
    <p>
      vmin - это наименьшее значение среди vw и vh. Если экран пользователя расположен горизонтально (экран ноутбука, например), то vmin = vh. Если это экран телефона, например, расположенный вертикально, то vmin = vw</p>
    <p>vmax - точно так же, но наоборот. Это наибольшее среди значений vw и vh.</p>
    <h3>fr - "единица гибкости"  </h3>
    <p>fr используется в <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout">гридах</a>. Об этой единице измерения очень хорошо описано в этой статье: <a target="_blank" href="https://medium.com/@stasonmars/что-такое-единица-гибкости-fr-в-css-доступным-и-простым-языком-2a3794c4444">Что такое единица гибкости fr в CSS, доступным и простым языком</a>. Если коротко, то fr позволяет разделять пространство на части.</p>
    <p>
      К примеру, элементы грида нужно разделить так, чтобы все они были равны. Для этого нужно задать для них ширину равную, например, 1fr. Тогда все элементы будут равны между собой.</p>
    <p>
      А что если у нас есть два блока в грид-контейнере, ширина которых должа относиться друг к другу как 1 к 3? Получается, всего частей у нас 4 (1+3), тогда ширина первого будет 25%, а второго 75%. И зачем же нам fr? Мы можем задать ширину первого 1fr, а второго 3fr и получить такой же результат. 
      Но почему бы просто ни использовать проценты? А что если мы точно знаем, что первый блок должен быть 50px в ширину, а второй и третий - делить между собой 
      оставшееся пространство так, чтобы второму досталось 25%, а третьему 75%? Если задать "50px 25% 75%", ничего не получится, потому что общая сумма будет равна 
      25% ширины контейнера + 75% ширины контейнера + 50px, что уже точно больше, чем 100% и блок выйдет за границу контейнера. Как раз здесь нам и 
      нужно использовать fr. Мы можем задать "50px 1fr 3fr" - и вуаля! Ведь fr разделить именно свободное пространство.
    </p>
    <p>Таким образом, fr позволяет нам делить имеющееся пространство на доли, отношение которых и задаётся этой единицей измерения. </p>
    <h3>Остальные единицы измерения </h3>
    <p>Также CSS поддерживает и другие  <a target="_blank" href="http://proglang.su/css/measurement-units">единицы измерения:</a></p>
    <ul>
      <li>mm (миллиметры),</li>
      <li>cm (сантиметры)</li>
      <li>ex (относительно высоты строчной буквы)</li>
      <li>ch (относительно ширины строчной буквы)</li>
      <li>in (дюймы)</li>
      <li>pt (типографские пункты = 1/72in = 0.3528mm)</li>
      <li>pc (пики. одна пика эквивалентна 12pt)</li>
    </ul>
    <p>и другие. Они значительно реже применяются на практике, но для общего развития, стоит изучить и их.</p>
  </div>
</article>
<article id="fonts">
  <div class="container">
    <h2>Форматирование текста</h2>
    <p>
      Знаете ли вы, что CSS имеет средства форматирования текста не хуже чем у Microsoft Word? Вы можете задать свой шрифт, жирность, начертание, цвет, тень, размер и еще множество параметров, чтобы получить идеально отформатированный текст. Для форматирования текста используется следующий основной набор свойств: </p>
    <ul class="can-print-break">
      <li> <a href="http://htmlbook.ru/css/font-family" target="_blank">font-family</a><br>Задаёт шрифт для элемента. К примеру, <code>font-family: Arial, sans-serif; </code>Изменяет шрифт на Arial, а если этого шрифта в системе нет, то берёт любой из установленных шрифтов семейства sans-serif. </li>
      <li> <a href="http://htmlbook.ru/css/font-size" target="_blank">font-size</a><br>Задаёт кегль для текста (размер шрифта). <code>font-size: 18px; </code>Задаёт размер шрифта в 18px. Могут быть использованы относительные значения: "larger" и "smaller", указывающие, что размер должен быть больше или меньше стандартного значения. </li>
      <li> <a href="http://htmlbook.ru/css/font-weight" target="_blank">font-weight</a><br>Устанавливает насыщенность (жирность) шрифта. Значением могут быть числа от 100 до 900 с шагом 100, а также bold, bolder, lighter и normal. <br><b>Примечание:</b> значения должны поддерживаться шрифтом! Если шрифт не поддерживает какие-то значения насыщенности, то вы не сможете задать эти значения и будет выбрано ближайшее поддерживающееся. </li>
      <li> <a href="http://htmlbook.ru/css/font-style" target="_blank">font-style</a><br>Определяет начертание шрифта. Может быть обычным (normal), курсивным (italic) и наклонным (oblique). <br>Наклонное начертание хоть и похоже на курсивной, однако, это разные вещи. Курсивным текст станет только в том случае, если шрифт поддерживает курсивное начертание. 
        Наклонный текст образуется путём программного наклона букв обычного шрифта.  
      </li>
      <li> <a href="http://htmlbook.ru/css/font-variant" target="_blank">font-variant</a><br>Благодаря этому свойству, можно отображать текст капителью. Это означает, что строчные буквы будут отображены как прописные, но уменьшенного размера. </li>
      <li> <a href="http://htmlbook.ru/css/letter-spacing" target="_blank">letter-spacing</a><br>Определяет интервал между символами. Желательно задавать значения в em. Принимает и отрицательные значения. </li>
      <li> <a href="http://htmlbook.ru/css/word-spacing" target="_blank">word-spacing </a><br>Устанавливает интервал между словами (ширина пробела)</li>
      <li> <a href="http://htmlbook.ru/css/text-indent" target="_blank">text-indent</a><br>Устанавливает ширину первой строки абзаца (красной строки)</li>
      <li> <a href="http://htmlbook.ru/css/text-transform" target="_blank">text-transform</a><br>Управляет регистром текста. К примеру, значение uppercase устанавливает все символы текста прописными.</li>
      <li> <a href="http://htmlbook.ru/css/text-decoration" target="_blank">text-decoration</a><br>Добавляет подчёркивание (underline), перечёркивание (line-through) или линию над текстом (overline). 
        Кроме того, значение none полностью убирает стандартные подчёркивания у ссылок. 
      </li>
      <li> <a href="http://htmlbook.ru/css/text-align" target="_blank">text-align</a><br>Выравнивание текста. Доступные значения: <b>center </b>(по центру), <b>justify </b>(по ширине строки), <b>start </b>(по левому краю, для тех языков, где текст идёт слева направо), <b>end </b>(по правому краю, для тех языков, где текст идёт слева направо)</li>
      <li> <a href="http://htmlbook.ru/css/text-shadow" target="_blank">text-shadow</a><br>Добавляет тень тексту. К примеру, <code>text-shadow: 1px 2px 3px black;</code>, где <br>первое значение (1px) &mdash; сдвиг по оси x, <br>второе значение (2px) &mdash; сдвиг по оси y,<br>третье значение (3px) &mdash; радиус размытия тени,<br>четвертое значение (black) &mdash; цвет тени. <br>Кроме того, таких групп значений может быть сколько угодно. К примеру, <code>text-shadow: 1px 2px 3px black, 0 0 1em red;</code></li>
      <li> <a href="http://htmlbook.ru/css/column-count" target="_blank">column-count</a><br>Задаёт количество колонок в тексте. Применяется, в основном, для газетной вёрстки.</li>
      <li> <a href="http://htmlbook.ru/css/line-height" target="_blank">line-height</a><br>Задаёт высоту строки. Если задавать без единиц измерения, например, <code>line-height: 2;</code>, значение будет воспринято как множитель. </li>
    </ul>
    <section>
      <h3>Собственные шрифты</h3>
      <p>Для подключения собственного шрифта используется правило <a href="http://htmlbook.ru/css/font-face" target="_blank">@font-face.</a></p>
      <pre data-lang="css">@font-face {
  font-family: 'Philosopher'; /* Название шрифта*/
  font-style: normal;         /* Начертание */
  font-weight: 400;           /* Насыщенность */
  src: url(./fonts/philosopher.woff2) format('woff2'); /* Путь к файлу шрифта и его формат */
}</pre>
      <p>Для подключение такого шрифта к элементу, используют код:</p>
      <pre data-lang="css">.selector {
  font-family: 'Philosopher', sans-serif;
}</pre>
    </section>
    <section>
      <h3>Google Fonts </h3>
      <p>Для упрощения подключения шрифтов, используют различные библиотеки шрифтов. К примеру, <a target="_blank" href="https://fonts.google.com/">Google Fonts</a>. Такие библиотеки содержат сотни шрифтов, а так же оптимизаторы для браузеров. 
        Всё что нам нужено &mdash; выбрать требуемый шрифт, выбрать, какие начертания и языки нам требуются (для русского языка Cyrillic),
        подключить в <code>&lt;head&gt;</code>стиль шрифта, имеющий примерно такой вид:
      </p>
      <pre data-lang="html">&lt;head&gt;
  ...
  &lt;link href="https://fonts.googleapis.com/css?family=Philosopher:400,700&display=swap&subset=cyrillic" rel="stylesheet"&gt;
  ...
&lt;/head&gt;</pre>
    </section>
  </div>
</article>
<article id="column-count">
  <div class="container">
    <h2>Многоколоночный текст</h2>
    <p>
      Время от времени возникает задача расположить список или текст в две колонки. Годы идут, CSS развивается, поколения верстальщиков сменяют поколения, но свои костыли люди как делали, так и делают. Мало кто знает, но в CSS появилось свойство <br><a href="http://htmlbook.ru/css/column-count" target="_blank">column-count</a>, позволяющее задать количество колонок для списка или текста. Также есть свойство <br><a href="http://htmlbook.ru/css/column-width" target="_blank">column-width</a>, которое задаёт минимальную ширину для колонки, <br><a href="http://htmlbook.ru/css/column-rule" target="_blank">column-rule</a>, отрисовывающее линию между колонками словно border,<br><a href="http://htmlbook.ru/css/column-gap" target="_blank">column-gap</a>, задающее расстояние между колонками и <br><a href="http://htmlbook.ru/css/columns" target="_blank">columns</a>, объединяющее в себе column-width и column-count. 
      <p>Разберемся на примерах из жизни. Простой пример: нужно сделать так, чтобы список располагался в две колонки. </p>
      <pre data-lang="html" data-code="col-count-1,col-count-2" hidden>&lt;ul&gt;
  &lt;li&gt;Lorem&lt;/li&gt;
  &lt;li&gt;ipsum&lt;/li&gt;
  &lt;li&gt;dolor&lt;/li&gt;
  &lt;li&gt;sit&lt;/li&gt;
  &lt;li&gt;amet&lt;/li&gt;
  &lt;li&gt;consectetur&lt;/li&gt;
  &lt;li&gt;adipisicing&lt;/li&gt;
  &lt;li&gt;elit&lt;/li&gt;
&lt;/ul&gt;</pre>
      <div data-run="col-count-1"></div>
      <p>Добавим следующий CSS-код:</p>
      <pre data-lang="css" data-code="col-count-2">ul {
  column-count: 2;
}</pre>
      <p>В результате получим это:</p>
      <div data-run="col-count-2"></div>
      <p>
        Просто, не правда ли? А теперь посмотрим на немного более сложный пример. Итак, наши клиенты - люди с планшетами. Наше веб-приложение похоже на газету и листать её нужно слева направо, а не вниз, как остальные сайты. Текст должен располагаться в три колонки на экран. 
        Общее количество колонок неизвестно, также, как и количество текста. 
      </p>
      <p>
        Из задания лишь понятно, что высота приложения должна быть равна высоте экрана пользователя, а за раз на экране должно быть отображено три колонки. Для начала, создадим контейнер, который бы занимал весь экран и имел прокрутку слева направо. </p>
      <pre data-lang="css">.overflow-container {
  height: 100vh;      /* занимает 100% высоты экрана */
  overflow-x: auto;   /* показывает горизонтальный скролл в том случае, если он нужен */
  overflow-y: hidden; /* скрывает вертикальный скролл даже если он нужен */
}     </pre>
      <p>
        Теперь определим стили для текста. Мы понимаем, что так как колонки должно быть три, то каждая колонка должна иметь ширину 1/3 от ширины страницы. Это означает, что ширина колонки должна быть 100vw/3. Но число 33.333333vw не очень красиво выглядит. А свойство column-width задаёт именно
        минимальную ширину колонки. То есть, ширина колонки всегда будет подбираться автоматически, однако, минимальная ширина будет такой, какой мы её зададим. 
        Давайте зададим ширину колонки в 30vw - это ровное число, которое меньше 33.3333vw. 
      </p>
      <pre data-lang="css">.col-3 {
  column-width: 30vw;
}</pre>
      <p>И добавим немного стиля. К примеру, расстояние между колонками и тонкую серую линию между ними.</p>
      <pre data-lang="css">.col-3 {
  column-width: 30vw;
  column-gap: 2em;
  column-rule: 1px solid #ccc;
}</pre>
      <p>Посмотрим, что получилось: </p><a class="codepen button" data-id="WNejwwa" data-height="500" data-default-tab="result">Запустить пример </a>
      <p>
        Если вы видите не три колонки, значит, по мнению вашего браузера, ширины окна недостаточно для размещения трёх колонок текста. Установите column-width немного меньше, поэкспериментируйте и получите приемлемый для вас результат. </p>
    </p>
  </div>
</article>
<article id="display">
  <div class="container">
    <h2>Свойство display</h2>
    <p>
      Одним из важнейший CSS-свойств является display. Оно позволяет переопределять тип отображения элемента, не изменяя семантику кода. Рассмотрим основные значения этого свойства:</p>
    <ol>
      <li>none &mdash; скрывает элемент;</li>
      <li>
        block &mdash; определяет элемент как "блочный", что означает, что элемент не обтекается другими объектами, а переносится на новую строку и заполняет её полностью. Следующий элемент будет отрисован под блочным элементом. 
        Является стандартным значением элементов div, p, ul, article, section и других;
      </li>
      <li>
        inline &mdash; определяет элемент как "строчный", что означает, что элемент ведёт себя как текст. Является стандартным значением элементов span, a, s, b и других;</li>
      <li>inline-block &mdash; смесь строчного и блочного. Фактически, являясь блочным, элемент получает возможность обтекаться строчными элементами, как тег img;</li>
      <li>flex &mdash; превращает элемент в flex-контейнер. Это означает, что внутренние элементы выстраиваются так, как мы зададим с помощью свойств <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/flex">flex, </a><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/flex-direction">flex-direction, </a><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/flex-wrap">flex-wrap, </a><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/align-items">align-items, </a><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/justify-content">justify-content</a> и других. Более подробно о flex-контейнерах стоит прочитать тут: <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Flexible_Box_Layout/Выравнивание_элементов_в_Flex_контейнере">Выравнивание элементов в Flex контейнере</a>;</li>
      <li>grid &mdash; превращает элемент в grid-контейнер. Гриды это новая технология построения сеток. При помощи свойств управления сетками, например, <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-columns">grid-template-columns</a>, мы можем управлять отображением содержимого внутри грида. Более подробно о гридах можно почитать здесь: <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout">Основные понятия Grid Layout</a>.</li>
    </ol>
    <section>
      <h3>Задачи</h3>
      <p>
        Задачи на добавление всего одной строки кода. Смотрите HTML-код, подумайте, какое CSS-свойство спасёт ситуацию. Поиграйтесь со значениями этого свойства. Все необходимые для выполнения задачи знания описаны в этой главе.</p>
      <p>1. Напишите CSS-код, позволяющий скрыть этот элемент </p><a class="codepen button" data-id="gOYPNzd">Посмотреть задание</a>
      <p>2. Не меняя HTML-кода, сделайте так, чтобы каждое предложение начиналось с новой строки</p><a class="codepen button" data-id="JjPGQBN">Посмотреть задание</a>
      <p>3. Сделайте так, чтобы все элементы списка шли в одну строку</p><a class="codepen button" data-id="xxKVKKm">Посмотреть задание</a>
      <p>4. Добавьте одно свойство так, чтобы меню стало широким </p><a class="codepen button" data-id="vYBGBLE" data-height="400">Посмотреть задание</a>
      <p>5. Сделайте так, чтобы счёт шёл слева направо, а не снизу вверх</p><a class="codepen button" data-id="ExYKYWM" data-height="400">Посмотреть задание</a>
      <p>6. Добавьте одну строку так, чтобы получилась таблица</p><a class="codepen button" data-id="yLBOBpq">Посмотреть задание</a>
    </section>
  </div>
</article>
<article id="box-sizing">
  <div class="container">
    <h2>Блочная модель и box-sizing</h2>
    <p> Элементы в CSS представляют собой набор слоёв: ширина и высота самого элемента (<a target="_blank" href="http://htmlbook.ru/css/width">width</a> и <a target="_blank" href="http://htmlbook.ru/css/height">height</a>), поля элемента (<a target="_blank" href="http://htmlbook.ru/css/padding">padding</a>), граница элемента (<a target="_blank" href="http://htmlbook.ru/css/border">border</a>) и отступы (<a target="_blank" href="http://htmlbook.ru/css/margin">margin</a>). <a href="http://htmlbook.ru/samlayout/blochnaya-verstka/blochnaya-model" target="_blank">Подробнее о блочной модели стоит почитать здесь.</a></p>
    <div data-run="box-model"></div>
    <pre data-lang="html" data-code="box-model" hidden>&lt;div class="box-model"&gt;
  &lt;div class="margin"&gt;margin
    &lt;div class="border"&gt;border
      &lt;div class="padding"&gt;padding
        &lt;div class="size"&gt;width&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
    <pre data-lang="css" data-code="box-model" hidden>.box-model {
  display: flex;
  justify-content: center;
}

.box-model * {
  text-align: center;
  border: 1px dashed black;
  padding: 10px;
  margin: 10px 24px 24px;
  font-size: 14px;
  font-family: monospace;
}

.box-model .margin {
  background: lightsalmon;
}

.box-model .border {
  background: navajowhite;
}

.box-model .padding {
  background: lightgreen;
}

.box-model .size {
  background: lightblue;
  width: 90px;
  height: 80px;
  position: relative;
  padding: 0 10px;
  text-align: left;
}

.box-model .size::after {
  content: 'height';
  position: absolute;
  writing-mode: vertical-lr;
  top: 10px;
  right: 0;
}
</pre>
    <section>
      <p>
        Долгое время в CSS изменение padding приводило к изменению width у элементов, из-за чего два одинаковых по ширине элемента с разными по ширине полями, в реальности имели разную ширину. Пример ниже демонстрирует этот недуг:</p>
      <pre data-lang="html" data-code="box-z-1,box-z-2">&lt;div class="one"&gt;padding: 0&lt;/div&gt;
&lt;div class="two"&gt;padding: 40px&lt;/div&gt;</pre>
      <pre data-lang="css" data-code="box-z-1">.one {
  width: 200px;
  height: 100px;
  padding: 0;
}
.two {
  width: 200px;
  height: 100px;
  padding: 40px;
}</pre>
      <pre data-lang="css" data-code="box-z-1,box-z-2" hidden>.one,.two{
  background: teal;
  color: white;
  margin: 20px auto;
}
.two{
  box-shadow: inset 0 0 0 40px darkcyan;
}</pre>
      <div data-run="box-z-1"></div>
      <p> <i>Для визуализации, padding был окрашен с помощью свойства box-shadow. В действительности же, задать цвет для padding невозможно!</i></p>
    </section>
    <section>
      <p>На помощь в борьбе с этим нелогичным, казалось бы, поведением пришел <a href="http://htmlbook.ru/css/box-sizing" target="_blank">box-sizing</a>. Добавим в наши блоки всего по одной строчке кода:</p>
      <pre data-lang="css" data-code="box-z-2">.one {
  width: 200px;
  height: 100px;
  padding: 0;
  box-sizing: border-box;
}
.two {
  width: 200px;
  height: 100px;
  padding: 40px;
  box-sizing: border-box;
}
</pre>
      <div data-run="box-z-2"></div>
    </section>
    <section>
      <p>
        Так стало гораздо проще работать с CSS, поэтому многие добавляют box-sizing: border-box всем элементам на сайте при помощи этого кода:</p>
      <pre data-lang="css">* {
  box-sizing: border-box;
}</pre>
      <p>
        Это стало хорошей и распространённой практикой, однако по умолчанию значением свойства box-sizing является стандартная модель content-box, возвращающий нас в те времена,
        когда приходилось вычислять ширину элемента по его полям.
      </p>
    </section>
  </div>
</article>
<article id="position">
  <div class="container">
    <h2>Позиционирование</h2>
    <p>position - это фундаментальное свойство CSS, которое позволяет определить, в каком месте браузер будет отрисовывать элементы. </p>
    <p>Свойство position обладает следующими значениями:</p>
    <ul>
      <li>static - значение по умолчанию. Элемент будет отрисован "нормально" </li>
      <li>
        relative - позволяет отрисовать элемент "нормально", но, благодаря CSS-свойствам top, right, bottom и left, появляется возможность сместить блок из "нормальной" позиции. </li>
      <li>
        absolute - самое интересное свойство. Положение блока рассчитывается при помощи top, right, bottom и left,но не относительно изначального места, а относительно ближайшего родителя с position не равным static или элемента body. </li>
      <li>fixed - положение относительно границ экрана. Также рассчитывается с помощью top, right, bottom и left, но родителем является сам экран. </li>
      <li>
        sticky - "прилипает" к границам экрана в том случае, если выходит за границы экрана. Также устанавливается при помощи top, right, bottom и left.Подробнее тут: <a target="_blank" href="https://medium.com/web-standards/sticky-bc7ff7088693">Как на самом деле работает position: sticky в CSS</a></li>
    </ul>
    <p>Поэкспериментировать с position: absolute можно здесь:</p><a class="codepen button" data-id="gOYwLmY" data-height="400">Запустить пример</a>
    <p>Поэкспериментировать с position: sticky можно тут:</p><a class="codepen button" data-id="rNBMWzp" data-height="400">Запустить пример</a>
    <section>
      <h3>Смещение блока: top, right, bottom и left</h3>
      <p>По умолчанию значением этих свойств является auto. Мы можем использовать для задания положения, например, px или %. </p>Используются в купе с нестатично спозиционированными блоками. 
      <ul>
        <li>top смещает блок сверху вниз;</li>
        <li>bottom смещает блок снизу вверх;</li>
        <li>left смещает блок слева направо;</li>
        <li>right смещает блок справа налево.</li>
      </ul>
    </section>
    <section>
      <h3>Слои и z-index</h3>
      <p>
        Иногда, сместив один блок относительно другого, они начинают "наезжать" друг на друга. Причём, не всегда так, как мы этого хотим. Что если мы хотим, чтобы блок, который отрисовался "под" вторым блоком, был отрисован "над" ним? 
        Для этого на помощь приходит свойство z-index. Значением этого свойства может быть просто любое число, без единиц измерения. 
        Установив z-index: 2 для первого блока и z-index: 1 для второго, мы точно будем знать, что первый блок будет отрисован "над" вторым, так как
        его z-index больше. По умолчанию же, "над" отрисовывается тот блок, который в структуре HTML был ближе к концу документа. 
      </p>
      <p>
        Если вы математик, то вам будет понятно следующее объяснение: наш экран имеет две координаты: X и Y. Координаты начинаются из верхнего левого угла. X направлен вправо. Y &mdash; вниз. А теперь представим себе ещё одну координату &mdash; Z. 
        Она направлена из той же точки, но перпендикулярно экрану, на зрителя. Это и есть z-index. 
      </p>
      <p>
        Если вы работали с фотошопом или какими-то другими графическими редакторами, то вам знакомо понятие "слои". Мы можем распологать различные изображенияна этих слоях, а в случае перекрытия, показан будет тот слой, что находится выше. И это тоже z-index. </p>
      <p>Раскомментируйте строку с z-index, чтобы понять, как работает это свойство.</p><a class="codepen button" data-id="KKPgNrX" data-height="400">Посмотреть задание</a>
    </section>
  </div>
</article>
<article id="pseudo">
  <div class="container">
    <h2>Псевдоклассы и псевдоэлементы</h2>
    <p>
      Псевдоклассы и псевдоэлементы решают группу задач, связанных с выбором конктерного элемента списка или с изменением поведения объекта в связи с возникновением какого-либо события.
      Здесь мы разберём лишь часть из существующих псевдоэлементов и псевдоклассов, а больше вы всегда сможете узнать здесь: <a href="https://developer.mozilla.org/ru/docs/Learn/CSS/Introduction_to_CSS/Pseudo-classes_and_pseudo-elements" target="_blank">Псевдоклассы и псевдоэлементы</a>
    </p>
    <h3>Псевдоклассы</h3>
    <p>Псевдоклассы представляют собой ключевое слово, начинающееся с двоеточия (:), которое добавляют после селектора: </p>
    <pre data-lang="css">selector:pseudo-class { ... }</pre>
    <p>Ниже приведён список наиболее популярных псевдоклассов</p>
    <ul> 
      <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/:hover">:hover</a><br>Срабатывает при наведении курсора на элемент</li>
      <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/:visited">:visited</a><br>Позволяет выбрать посещённые ссылки </li>
      <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/:active">:active</a><br>Срабатывает при нажатии на элемент, но может быть применим только к элементам <code>&lt;a&gt;</code>и <code>&lt;button&gt; </code></li>
      <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/:focus">:focus</a><br>Срабатывает при получении элементом фокуса. Работает только для элементов <code>&lt;a&gt;</code><code>&lt;button&gt;</code><code>&lt;input&gt;</code><code>&lt;textarea&gt;</code></li>
      <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/:checked">:checked</a><br>Срабатывает для элемента <code>&lt;input type="checkbox"&gt; </code>или <code>&lt;input type="radio"&gt; </code>. Позволяет применять стили в том случае, если на элементе стоит отметка  </li>
      <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/:disabled">:disabled</a><br>Срабатывает, если элемент имеет атрибут <code>disabled</code>, к примеру, элемент  <code>&lt;input type="..." disabled&gt; </code>или <code>&lt;button disabled&gt; </code></li>
      <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/:required">:required</a><br>Срабатывает, если элемент имеет атрибут  <code>required</code>, всегда для элемента  <code>&lt;input required&gt;</code></li>
      <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/:first-child">:first-child</a><br>Позволяет выбрать первый элемент в своем родителе</li>
      <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/:last-child">:last-child</a><br>Позволяет выбрать последний элемент в своем родителе</li>
      <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/:nth-child">:nth-child</a><br>Позволяет выбирать один или более элементов, основываясь на их позиции среди группы соседних элементов. <br><b>Примеры:</b><br><code>ul li:nth-child(2)</code>Выберет второй элемент<br><code>ul li:nth-child(2n)</code>Выберет каждый второй элемент (через один)<br><code>ul li:nth-child(3n+1)</code>Выберет 1,4,7,9 ... и так далее, через два элементы. </li>
      <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/:nth-last-child">:nth-last-child</a><br>Точно так же, но счёт идёт с последнего элемента к первому. К примеру, для выбора предпоследнего элемента списка:<code>ul li:nth-last-child(2)</code></li>
      <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/:not">:not()</a><br>"НЕ". Это функция, принимающая селектор внутрь скобок. К примеру, нам нужно найти все ссылки, у которых нет атрибута <code>target</code>:<br><code>a:not([target])</code><br>Ещё пример: требуется найти все статьи, не имеющие класса <code>.top</code>:<br><code>article:not(.top)</code></li>
    </ul>
    <h3>Псевдоэлементы</h3>
    <p>Псевдоэлементов значительно меньше, а отличить их можно по двойному двоеточию (::), которое добавляется к селектору. </p>
    <pre data-lang="css">selector::pseudo-element { ... }</pre>
    <p>Браузерами поддерживается и устаревший синтаксис с одинарным двоеточием. </p>
    <p>
      Псевдоэлементы ведут себя как элементы, то есть, у них есть размеры, они могут быть спозиционированы, их видно. Псевдоклассы же мы увидеть ен могли, могли лишь только увидеть их влияние на элементы. Рассмотрим псевдоэлементы подробнее:</p>
    <ul>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/CSS/::before" target="_blank">::before</a><br>Создаёт псевдоэлемент, который будет являться первым потомком элемента. Не работает без свойства <code>content: '';</code><br><code>
           a::before{
            content: '♥';
          }</code>В этом примере, перед каждой ссылкой на сайте будет добавляться сердечко. </li>
      <li><a href="https://developer.mozilla.org/ru/docs/Web/CSS/::after" target="_blank">::after</a><br>Работает точно так же, как и ::before, но псевдоэлемент создаётся в самом конце и будет являться последним потомком.  </li>
    </ul>
    <div class="no-print-break">
      <p>С остальными псевдоэлементами вы познакомитесь позже, на личной практике. Они используются заметно реже. Конечно, ссылки на них я приведу:</p>
      <ul>
        <li><a href="https://developer.mozilla.org/ru/docs/Web/CSS/::first-letter" target="_blank">::first-letter</a></li>
        <li><a href="https://developer.mozilla.org/ru/docs/Web/CSS/::first-line" target="_blank">::first-line</a></li>
        <li><a href="https://developer.mozilla.org/ru/docs/Web/CSS/::selection" target="_blank">::selection</a></li>
        <li><a href="https://developer.mozilla.org/ru/docs/Web/CSS/::backdrop" target="_blank">::backdrop </a></li>
      </ul>
    </div>
  </div>
</article>
<article id="image">
  <div class="container">
    <h2>Картинка в тексте</h2>
    <p>
      Часто, бывает нужно вставить картинку в текст. Но работает это не всегда так, как мы это задумывали. Попробуем вставить картинку без стилей и посмотрим, что получится.</p>
    <section>
      <p>Код примера предельно прост: </p>
      <pre data-lang="html" data-code="image-in-text-1,image-in-text-2,image-in-text-4">&lt;p&gt;
  &lt;img src="./assets/images/image.svg" alt="Just image"&gt;
  Lorem ipsum dolor sit amet consectetur adipisicing elit. Hic commodi maiores excepturi dolore cupiditate sit obcaecati, 
  repellat doloribus rerum! Dicta eius aliquid eaque sed sequi obcaecati debitis quos veniam placeat.
&lt;/p&gt;
&lt;p&gt;
  Itaque voluptates eum nihil minima quo iure voluptas, atque amet molestias, perspiciatis sed cupiditate nemo inventore velit 
  soluta iste ut nesciunt! Qui fuga nesciunt accusantium magnam officiis corrupti, quibusdam amet.
&lt;/p&gt;
&lt;p&gt;
  Soluta, laudantium in. Dolorem laboriosam nobis nihil iste eum sapiente maxime, facilis minus atque debitis corporis quasi, 
  molestias delectus magni placeat ipsum iure perspiciatis doloremque repudiandae rem tenetur, in dolorum. 
&lt;/p&gt;
</pre>
      <div data-run="image-in-text-1"></div>
    </section>
    <section>
      <p>
        Как видите, картинка стала частью первой строки текста. Нам редко нужно, чтобы поведение было именно таким. Чаще нам необходимо сделать так, чтобы картинка обтекалась текстом. Для этого существует свойство float. </p>
      <p>Добавим к нашему примеру <a href="http://htmlbook.ru/css/float" target="_blank">float</a>: left и посмотрим, что получится</p>
      <pre data-lang="css" data-code="image-in-text-2">img {
  float: left;
}
</pre>
      <div data-run="image-in-text-2"></div>
      <p>Здесь мы видим, что картинка стала обтекаться текстом. Правда, из-за того, что текста много, мы не видим одного подводного камня этого решения.</p>
    </section>
    <section>
      <p>Давайте уберём последние два абзаца и посмотрим, что будет</p>
      <div style="background: #f2f2f2; padding: 15px;">
        <p style="margin: 10px 0;"><img src="./assets/images/image.svg" alt="Just image" style="float:left;">Lorem ipsum dolor... </p>
      </div>
      <p>
        Обратите внимание, что-то пошло не так и даже этот абзац, не относящийся к примеру, всё равно обтекается картинкой. Явно не то, чего мы ожидали. Всё дело в том, что флоаты (поплавки) "всплывают" над родительским элементом, поэтому его высота больше не зависит от нашей картинки. </p>
    </section>
    <section>
      <p>Для того, чтобы исправить подобное поведение, нужно воспользоваться "очисткой" &mdash; <a href="http://htmlbook.ru/css/clear" target="_blank">clear</a>. Изменим наш код следующим образом:</p>
      <pre data-lang="html" data-code="image-in-text-3">&lt;p&gt;
  &lt;img src="./assets/images/image.svg" alt="Just image"&gt;
  Lorem ipsum dolor...
&lt;/p&gt;
&lt;div class="clear"&gt;&lt;/div&gt;</pre>
      <pre data-lang="css" data-code="image-in-text-3">img {
  float: left;
}
.clear {
  clear: both;
}</pre>
    </section>
    <section>
      <div data-run="image-in-text-3"></div>
      <p>
        Как видите, абзац, который вы сейчас читаете, находится уже за пределами примера. Добавив такой чистящий элемент в самый конец родительского контейнера, мы смогли вернуть высоту контейнера к нормальному уровню. </p>
    </section>
    <section>
      <p>
        В предыдущих примерах мы увидели, как задать обтекание картинки текстом так, чтобы картинка оказалась слева. Точно так же мы можем обтекать её и с другой стороны. </p>
      <pre data-lang="css" data-code="image-in-text-4">img {
  float: right;
}
</pre>
      <div data-run="image-in-text-4"></div>
      <p>И если мы не уверены, что текста будет достаточно, не забудем добавить в конец контейнера clear: both.</p>
      <pre data-lang="css" data-code="image-in-text-5">img {
  float: left;
}
.clear {
  clear: both;
}</pre>
      <pre data-lang="html" data-code="image-in-text-5" hidden>&lt;p&gt;
  &lt;img src="./assets/images/image.svg" alt="Just image"&gt;
  Lorem ipsum dolor sit amet consectetur adipisicing elit. Hic commodi maiores excepturi dolore cupiditate sit obcaecati, 
  repellat doloribus rerum! Dicta eius aliquid eaque sed sequi obcaecati debitis quos veniam placeat.
&lt;/p&gt;</pre>
      <div data-run="image-in-text-5"></div>
    </section>
    <section>
      <p>Подведём итоги. Для того, чтобы вставить картинку в текст и сделать так, чтобы она обтекалась, нужно воспользоваться свойством </p><a href="http://htmlbook.ru/css/float" target="_blank">float</a>, а для того, чтобы восстановить размер контейнера в том случае, если картинка стала вылезать за его пределы, нужно использовать свойство <a href="http://htmlbook.ru/css/clear" target="_blank">clear</a>.
    </section>
  </div>
</article>
<article id="css-variables">
  <div class="container"> 
    <h2>CSS переменные</h2>
    <p>
      В крупных проектах часто используется ограниченная палитра цветов, составленная дизайнером. В ходе разработки, мы используем эту палитру по всему проекту. Проект растёт, количество файлов в нём, соответственно, тоже. И вот, наступает он &mdash; РЕДИЗАЙН. Слово, доставляющее боль и страдания любому верстальщику.
      Так уж получилось, что вам повезло и в проекте просто поменялось несколько цветов. Допустим, салатовый стал ярко-зелёным, а красный стал томатным. 
      Звучит не так уж и сложно. Простенький такой редизайн. И пошли мы по всем CSS-файлам проекта искать изменённые цвета. Причём, через какое-то время 
      мы ещё и заметили, что в прошлый раз, дизайнер немножко ошибался с цветами и вместо одного кода салатового цвета <code>#3bff00</code>, он использовал множество вариаций, незначительно отличающихся друг от друга. К примеру, <code>#3bff01</code>. Как мы понимаем, простым поиском и заменой нам уже не обойтись. Теперь придётся искать на всех страницах вашего сайта салатовые элементы. 
      Уже представляете, сколько времени у вас на это уйдёт? А ведь нам еще красный на томатный менять. 
    </p>
    <p>В борьбу с такими вот проблемами включились <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/Using_CSS_custom_properties">CSS переменные (CSS custom properties) (пользовательские свойства CSS)</a>. Мы можем изначально задать переменную для салатового цвета и использовать только её. А если мы при разработке увидим, что есть два почти одинаковых салатовых 
      цвета, то можем подойти к дизайнеру и спросить, какой из них правильный. Дизайнеры тоже люди и тоже ошибаются. Это надо учитывать. 
      Итак, зададим два цвета: салатовый и томатный:
    </p>
    <pre data-lang="css">:root {
  --green-light: #3bff00;
  --tomato: #ff6347;
}</pre>
    <p>Как вы видете, CSS переменные задаются в псевдо-классе <code>:root</code></p>
    <p>Теперь будем использовать эти переменные в CSS:</p>
    <pre data-lang="css">menu {
  background-color: var(--green-light);
  border: 1px solid var(--tomato);
}</pre>
    <p>К следующему редизайну, когда <code>#3bff00 </code>поменяется на <code>#00ad68</code>, мы лишь изменим код цвета в <code>:root </code>, и весь проект перекрасится. Одна секунда вместо часов страданий. </p>
    <p>
      Рекомендую называть переменные не так, как в примере. Наиболее правильными будут названия, исходя из того, где используется цвет или вообще какие-то абстрактныеназвания. Например <code>--accent, --dark-bg, --light-shadow</code>, ... </p>
    <section>
      <h3>Улучшение адаптивности</h3>
      <p>В CSS переменные можно задавать не только цвета, но и числа. А ещё мы можем изменять переменные, в зависимости от того, </p>каким устройством пользуется посетитель нашего сайта. 
      <pre data-lang="css">:root {
  --font-large: 20px;
}

h3 {
  font-size: var(--font-large);
}

@media(min-width: 700px) {
  :root {
    --font-large: 32px;
  }
}
</pre>
      <p>Так, если ширина экрана пользователя больше 700 пикселей, все свойства, использующие переменную </p><code>--font-large</code>, увеличатся. 
      <p>Кроме того, к CSS переменным можно получить доступ из JavaScript, <a target="_blank" href="https://css-tricks.com/updating-a-css-variable-with-javascript/">но это уже совсем другая история</a></p>
    </section>
  </div>
</article>
<article id="margin-0-auto">
  <div class="container">
    <h2>Выравнивание блока по центру</h2>
    <p>
      Этот фокус позволяет центрировать блок заранее определённой ширины, независимо от ширины экрана. Кроме
      того, если использовать max-width вместо width, то, даже если размер экрана пользователя окажется меньше
      ширины этого блока, то блок не выйдет за границы экрана, а будет равен ширине экрана. Это весьма
      распространенная практика
    </p>
    <h3>Пример:</h3>
  </div>
  <div data-run="auto-margin-1"></div>
  <div class="container">
    <p>Код:</p>
    <pre data-lang="html" data-code="auto-margin-1">&lt;div class="block"&gt;&lt;/div&gt;
</pre>
    <pre data-lang="css" data-code="auto-margin-1">.block {
  max-width: 500px;
  margin: 0 auto; /* центрирует блок так, что правый и левый маргин становятся одинаковыми */
}</pre>
    <pre data-lang="css" data-code="auto-margin-1" hidden>.block {
  height: 110px; 
  background: teal; 
}
</pre>
  </div>
  <div class="container">
    <h3>Задача</h3>
    <p>Сделать шапку для сайта avito.ru. Серый фон шапки должен быть растянут на всю страницу, а элементы меню должны быть в центре, не зависимо от ширины экрана пользователя</p>
  </div>
  <div data-run="auto-margin-2"></div>
  <pre data-lang="html" data-code="auto-margin-2" hidden>&lt;div class="sol1"&gt;
  &lt;div class="content"&gt;
    &lt;div class="left"&gt;&lt;a href="#"&gt;Объявления&lt;/a&gt;&lt;a href="#"&gt;Магазины&lt;/a&gt;&lt;a href="#"&gt;Бизнес&lt;/a&gt;&lt;a href="#"&gt;Помощь&lt;/a&gt;&lt;/div&gt;
    &lt;div class="right"&gt;&lt;a class="primary" href="#"&gt;Вход и регистрация&lt;/a&gt;&lt;a class="button primary" href="#"&gt;Подать объявление&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
  <pre data-lang="css" data-code="auto-margin-2" hidden>.sol1 {
  background-color: #f7f7f7;
  font-size: 14px;
  border-bottom: 1px solid #d8d8d8;
  border-top: 1px solid #d8d8d8;
}

.sol1 .content {
  margin: 0 auto;
  max-width: 900px;
  display: flex;
  justify-content: space-between;
  padding: 0 32px;
}

.sol1 .content .left {
  padding: 14px 0;
}

.sol1 .content .left a {
  margin-right: 18px;
}

.sol1 .content .right {
  padding: 7px 0;
}

.sol1 .content .right a.button {
  margin-left: 29px;
}

.sol1 a {
  color: #a1a1a1;
  text-decoration: none;
}

.sol1 a:hover {
  color: #ff6163;
}

.sol1 .button {
  display: inline-block;
  padding: 6px 13px;
  border-radius: 3px;
  border: 1px solid transparent;
  box-shadow: none;
}

.sol1 a.primary {
  color: #0091d9;
}

.sol1 a.primary:hover {
  color: #ff6163;
}

.sol1 .button.primary {
  background-color: #01aaff;
  color: white;
}

.sol1 .button.primary:hover {
  color: white;
  background-color: #0099e6;
}

@media (max-width: 720px) {
  .sol1 {
    font-size: 1.5vw;
  }

  .sol1 .content {
    padding: 0 3.5vw;
  }

  .sol1 .content .left {
    padding: 1.5vw 0;
  }

  .sol1 .content .left a {
    margin-right: 2vw;
  }

  .sol1 .content .right {
    padding: 0.7vw 0;
  }

  .sol1 .content .right a.button {
    margin-left: 3.2vw;
    padding: 0.6vw 1.5vw;
  }
}</pre>
</article>
<article id="flex">
  <div class="container">
    <h2>Самый правильный способ разнести блоки в разные стороны</h2>
    <p>Способ основывается на применении <a href="https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox" target="_blank">флекс-контейнера</a>, внутри которого находятся два блока. Оперируя свойством <a href="http://htmlbook.ru/css/justify-content" target="_blank">justify-content</a>, можно добиться различных вариантов размещения этих двух блоков внутри флекс-контейнера. Нас же сейчас интересует
      значение "space-between", равномерно распределяющее блоки по ширине флекс-контейнера, прижимая к его краям первый и последний блоки. 
      Ширина блоков будет выбираться автоматически, в зависимости от контента, содержащегося внутри блока. 
      Кроме того, ширину блока, при необходимости, можно зафиксировать свойством <a href="http://htmlbook.ru/css/width" target="_blank">width</a>, если это потребуется. 
    </p>
    <p>Этот метод используется, в основном, для построения "шапки" сайта, но может быть использован и в других частях сайта или 
      <nobr>веб-приложения. </nobr>Для полного понимания работы флекс-контейнеров, рекомендую поиграть в игру <a href="https://flexboxfroggy.com/" target="_blank">Flexbox Froggy</a>
    </p>
    <section>
      <p>Пример:</p>
      <div data-run="flex-justify-1"></div>
      <p>Код:</p>
      <pre data-lang="html" data-code="flex-justify-1">&lt;div class="container"&gt;
  &lt;div class="box-left"&gt;
    &lt;span&gt;Brand&lt;/span&gt;
    &lt;span&gt;Stores&lt;/span&gt;
    &lt;span&gt;Actions&lt;/span&gt;
    &lt;span&gt;Contacts&lt;/span&gt;
  &lt;/div&gt;
  &lt;div class="box-right"&gt;
    &lt;span&gt;Settings&lt;/span&gt;
    &lt;span&gt;Account&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
      <pre data-lang="css" data-code="flex-justify-1">.container {
  /* Задаём флекс-бокс (позволяет влиять на расположение дочерних элементов) */
  display: flex;
  /* Говорим элементам встать так, чтобы между ними, по возможности, образовывалось расстояние */
  justify-content: space-between; 
}

.box-left {
  /* Здесь можно задать какие-то стили для левого блока */
}

.box-right {
  /* Здесь можно задать какие-то стили для правого блока */
}
</pre>
      <pre data-lang="css" data-code="flex-justify-1" hidden>.container {
  background: lightblue;
  padding: 5px;
}

.box-left {
  background: teal;
}

.box-right {
  background: blueviolet;
}

.container span {
  display: inline-block;
  padding: 10px 20px;
  background: rgba(255, 255, 255, 0.5);
  margin: 5px;
}

@media (max-width: 720px) {
  .container {
    padding: 5px 1px;
    font-size: 3.5vw;
  }

  .container span {
    margin: 2px;
    padding: 10px 2px;
  }
}
</pre>
    </section>
    <section>
      <h3>Задача</h3>
      <p>
        Сделать шапку для сайта habr.com так, чтобы правая и левая часть меню были разнесены при помощи
        флекс-бокса
      </p>
    </section>
  </div>
  <pre data-lang="html" data-code="habr-header" hidden>&lt;div class="sol2"&gt;
  &lt;div class="content"&gt;
    &lt;div class="left"&gt;&lt;a class="current" href="#"&gt;Публикации&lt;/a&gt;&lt;a href="#"&gt;Новости&lt;/a&gt;&lt;a href="#"&gt;Пользователи&lt;/a&gt;&lt;a href="#"&gt;Хабы&lt;/a&gt;&lt;a href="#"&gt;Компании&lt;/a&gt;&lt;a href="#"&gt;Песочница&lt;/a&gt;&lt;/div&gt;
    &lt;div class="right"&gt;&lt;a class="button default" href="#"&gt;Войти&lt;/a&gt;&lt;a class="button primary" href="#"&gt;Регистрация&lt;/a&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
  <pre data-lang="css" data-code="habr-header" hidden>.sol2 {
  border-bottom: 1px solid #d5dddf;
  border-top: 1px solid #d5dddf;
  font-size: 15px;
  background: white;
  margin-top:10px;
}

.sol2 .content {
  max-width: 900px;
  margin: 0 auto;
  padding: 0 32px;
  display: flex;
  justify-content: space-between;
}

.sol2 .right {
  padding: 16px;
  white-space: nowrap;
}

.sol2 .right .button {
  margin: 0 0 0 10px;
}

.sol2 a {
  display: inline-block;
  padding: 23px 0;
  margin-right: 28px;
  text-decoration: none;
  color: #838a92;
}

.sol2 a:hover {
  color: #5096b1;
}

.sol2 a.current {
  color: #464646;
}

.sol2 .button {
  padding: 8px 13px;
  border: 1px solid transparent;
  border-radius: 3px;
  font-size: 13px;
  box-shadow: none;
}

.sol2 .button.default {
  border-color: #a4afba;
  background-color: white;
}

.sol2 .button.default:hover {
  border-color: #65a3be;
}

.sol2 .button.primary {
  background-color: #65a3be;
  border-color: transparent;
  color: white;
}

.sol2 .button.primary:hover {
  background-color: #4986a1;
}

@media (max-width: 900px) {
  .sol2 {
    font-size: 1.5vw;
  }

  .sol2 .content {
    padding: 0 3.5vw;
  }

  .sol2 .right {
    padding: 1.5vw;
  }

  .sol2 .right .button {
    margin: 0 0 0 0.5vw;
  }

  .sol2 a {
    padding: 2.5vw 0;
    margin-right: 1.4vw;
  }

  .sol2 .button {
    padding: 0.8vw 1.4vw;
    font-size: 1.4vw;
  }
}
</pre>
  <div data-run="habr-header"></div>
</article>
<article id="relative-absolute">
  <div class="container">
    <h2>Горизонтальное и вертикальное центрирование блока</h2>
    <p>
      Эта техника применяется, в основном, для вёрстки модальных окон. Основывается на том, что блок с position: absolute смещается относительно ближайшего родителя с position: relative | absolute | fixed. 
      Смещение задаётся при помощи CSS-свойств 
    </p>
    <ul>
      <li><a href="http://htmlbook.ru/css/top" target="_blank">top</a></li>
      <li><a href="http://htmlbook.ru/css/right" target="_blank">right</a></li>
      <li><a href="http://htmlbook.ru/css/bottom" target="_blank">bottom</a></li>
      <li><a href="http://htmlbook.ru/css/left" target="_blank">left</a></li>
    </ul>
    <p>
      Если мы используем единицу измерения % для задания смещения, важно помнить, что процент берётся относительно родительского контейнера. Это значит, что left: 50% сместит блок на 50% от ширины родителя, а не от собственной ширины. 
      Для того, чтобы сместить блок на 50% относительно собственной ширины, необходимо использовать свойство <a href="http://htmlbook.ru/css/transform" target="_blank">transform</a> с функцией translateX(50%) - движение по оси X, translateY(50%) - движение по оси Y или translate(50%, 50%) - движение по обеим осям.
    </p>
    <p>
      В примере ниже показано, как мы сначала смещаем абсолютно спозиционированный блок на 50% слева направо (left) и на 50% сверху вниз (top) относительно контейнера, а затем, смещаем на 50% вверх и на 50% вправо относительно самого себя (transform: translate(-50%, -50%)), чтобы блок встал ровно по центру контейнера.</p>
    <p>
      Дело в том, что в CSS, началом координат является верхняя левая точка элемента, а не центр элемента. Поэтому нам не достаточно просто подвинуть блок на 50% вниз и вправо, так как тогда в центре контейнера окажется левый верхний угол блока, а не центр блока.</p>
    <section>
      <h3>Пример:</h3>
      <div data-run="rel-abs-center"></div>
      <p>Код:</p>
      <pre data-lang="html" data-code="rel-abs-center">&lt;div class="container"&gt;
  &lt;div class="block"&gt;&lt;/div&gt;
&lt;/div&gt;
</pre>
      <pre data-lang="css" data-code="rel-abs-center">.container {
  position: relative;
  width: 100%;
  height: 250px;
}

.block {
  position: absolute; /* позволяет двигать блок относительно родительского релятивного контейнера */
  top: 50%; /* смещаем блок на 50% от высоты родителя */
  left: 50%; /* смещаем блок на 50% от ширины родителя */
  transform: translate(-50%, -50%); /* смещаем блок на 50% от ширины и высоты этого блока */
  width: 120px;
  height: 80px;
}
</pre>
      <pre data-lang="css" data-code="rel-abs-center" hidden>.container {
  background: lightblue;
}

.block {
  background: teal;
}
</pre>
    </section>
  </div>
  <div class="container">
    <section>
      <h3>Задача</h3>
      <p>Сделать просмотр изображений как на dns-shop.ru</p>
      <ul>
        <li>Размер внешнего контейнера: 100% * 100vh</li>
        <li>Вместо картинок можно использовать цветные блоки</li>
        <li>Стрелочки: <a href="./assets/images/angle-left-sm.svg" target="_blank">arrow-left</a>, <a href="./assets/images/angle-right-sm.svg" target="_blank">arrow-right</a>; изображение кнопки "закрыть": <a href="./assets/images/times-sm.svg" target="_blank">close</a>.</li>
      </ul>
    </section>
  </div>
  <div class="no-print-break" data-run="dns-modal" data-height="90vh"></div>
  <pre data-lang="html" data-code="dns-modal" hidden>&lt;div class="sol3"&gt;
  &lt;div class="title"&gt;iPhone Xs Max&lt;/div&gt;
  &lt;button class="button close"&gt;&lt;/button&gt;
  &lt;button class="button left"&gt;&lt;/button&gt;
  &lt;button class="button right"&gt;&lt;/button&gt;
  &lt;div class="image-container"&gt;&lt;img src="./assets/images/iphonexsmax-1.jpg" alt="iPhone Xs Max"&gt;&lt;/div&gt;
  &lt;div class="slider-container"&gt;
    &lt;button class="button left"&gt;&lt;/button&gt;
    &lt;button class="thumb active"&gt;&lt;img src="./assets/images/iphonexsmax-2.jpg" alt="Next"&gt;&lt;/button&gt;
    &lt;button class="thumb"&gt;&lt;img src="./assets/images/iphonexsmax-3.jpg" alt="Next"&gt;&lt;/button&gt;
    &lt;button class="thumb"&gt;&lt;img src="./assets/images/iphonexsmax-4.jpg" alt="Next"&gt;&lt;/button&gt;
    &lt;button class="thumb"&gt;&lt;img src="./assets/images/iphonexsmax-5.jpg" alt="Next"&gt;&lt;/button&gt;
    &lt;button class="button right"&gt;&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
  <pre data-lang="css" data-code="dns-modal" hidden>.sol3 {
  position: relative;
  width: 100%;
  height: 100%;
  min-height: 550px;
  overflow: hidden;
  background: white;
}

.sol3 .title {
  position: absolute;
  top: 30px;
  left: 30px;
  font-size: 24px;
  font-weight: bold;
  color: #444;
}

.sol3 .image-container {
  position: absolute;
  bottom: 50%;
  right: 50%;
  transform: translate(50%, 50%);
  width: 70%;
  height: 60%;
  text-align: center;
}

.sol3 .image-container img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

.sol3 .slider-container {
  position: absolute;
  bottom: 30px;
  right: 50%;
  width: 320px;
  height: 80px;
  margin-right: -160px;
  display: flex;
  justify-content: space-between;
}

.sol3 .slider-container .thumb {
  text-align: center;
  padding: 8px;
  background: white;
  border: 1px solid #d8d8d8;
  margin: 5px;
  width: 70px;
  height: 70px;
  border-radius: 4px;
  cursor: pointer;
  box-shadow: none;
}

.sol3 .slider-container .thumb img {
  display: inline-block;
  max-width: 100%;
  max-height: 100%;
  opacity: 0.7;
}

.sol3 .slider-container .thumb.active {
  border-color: #464646;
}

.sol3 .slider-container .thumb.active img,
.sol3 .slider-container .thumb:hover img {
  opacity: 1;
}

.sol3 .slider-container .button {
  width: 60px;
}

.sol3 .slider-container .button.left {
  left: auto;
  right: 100%;
  width: 40px;
}

.sol3 .slider-container .button.right {
  right: auto;
  left: 100%;
  width: 40px;
}

.sol3 .button {
  position: absolute;
  bottom: 50%;
  transform: translateY(50%);
  background: white;
  min-width: 30px;
  min-height: 30px;
  border: none;
  cursor: pointer;
  opacity: 0.4;
  background-repeat: no-repeat;
  background-position: center center;
  background-size: contain;
  width: 80px;
  height: 80px;
  box-shadow: none;
}

.sol3 .button:hover {
  opacity: 1;
}

.sol3 .button.left {
  left: 0;
  background-image: url('./assets/images/angle-left-sm.svg');
}

.sol3 .button.right {
  right: 0;
  background-image: url('./assets/images/angle-right-sm.svg');
}

.sol3 .button.close {
  position: absolute;
  top: 30px;
  right: 30px;
  transform: none;
  width: 30px;
  height: 30px;
  background-image: url('./assets/images/times-sm.svg');
}

@media (max-width: 500px) {
  .sol3 .slider-container {
    transform: scale(0.8);
  }
}</pre>
</article>
<article id="layouts">
  <div class="container">
    <h2>Многоколоночные макеты</h2>
    <p>
      При вёрстке сайта, одной из первых задач верстальщика является создание основного шаблона. Основным шаблоном в данном случае называется вёрстка без контента - это совокупность шапки сайта, меню, 
      футера и прочих элементов, которые встречаются на каждой странице.
    </p>
    <p>
      Итак, попробуем сверстать простой макет сайта. Сверху у нас будет шапка сайта, слева будет навигация по разделу сайта, справа контент, а снизу футер. Стандартный шаблон, ничего необычного. Начнём с HTML.</p>
    <pre data-lang="html" data-code="lay1,lay2,lay3,lay4,lay5">&lt;div class="main-container"&gt;
  &lt;header&gt;Header&lt;/header&gt;
  &lt;nav&gt;Site navigation&lt;/nav&gt;
  &lt;main&gt;Site content&lt;/main&gt;
  &lt;footer&gt;Footer&lt;/footer&gt;
&lt;/div&gt;
</pre>
    <p>Если мы запустим это прямо сейчас, мы лишь увидим, как все эти элементы расположились друг под другом. Придётся добавить стилей. </p>
    <section> 
      <h3>Float</h3>
      <p>
        В древние времена существовало несколько вариантов вёрстки макетов, а самым адекватным из них был float. Как мы выяснили в одной из предыдущих глав,с помощью float можно сделать так, чтобы картинка обтекалась текстом. То же можно применить и к блокам. Если мы возьмём два блочных элемента
        с определенными заранее шириной и высотой, то, добавив к ним <code>float: left;</code>, мы увидим, как эти два блочных элемента выстроятся в один ряд, если ширина страницы это позволит. 
      </p>
      <pre data-lang="css" data-code="lay1">.main-container {
  margin: 0 auto;
  max-width: 800px;
}
header {
  height: 50px;
  background: cornflowerblue;
}
nav {
  height: 80px;
  background: darksalmon;
  width: 20%;   /* Задаём ширину блока навигации */
  float: left;  /* Устанавливаем обтекание */  
}
main {
  height: 120px;
  background: khaki;
  width: 80%;   /* Задаём ширину контента */
  float: left;  /* Устанавливаем обтекание */
}
footer {
  clear: both;  /* Сбрасываем обтекание */
  height: 50px;
  background: darkseagreen;
}
</pre>
      <div data-run="lay1"></div>
      <p>Казалось бы, на этом можно закончить наш урок, но, если хорошо подумать, можно увидеть, как много проблем мы породили этим решением:</p>
      <ol>
        <li>Мы не можем жёстко зафиксировать ширину навигационного меню</li>
        <li>Если перед футером нам потребуется вставить какой-то блок, например, рекламный, вёрстка "поедет", ведь мы благополучно забудем про <code>clear: both;</code></li>
        <li>Высота навигации никак не зависит от высоты контента и наоборот. Под более коротким блоком будет пустота.</li>
      </ol>
      <p>Подробнее о float читайте тут:<a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/float">float</a></p>
    </section>
    <section>
      <h3>Flex</h3>
      <p>Рассмотрим более современный способ. Мы можем использовать<code>display: flex;</code>у <code>.main-container</code>, тогда мы сможем избавиться от пары недостатков предыдущего примера. </p>
      <pre data-lang="css" data-code="lay2,lay4">.main-container {
  margin: 0 auto;
  max-width: 800px;
  display: flex;        /* Объявляем контейнер флексом */
  align-items: stretch; /* Высота элементов должна подстраиваться по высоте самого высокого элемента */
  flex-wrap: wrap;      /* Если не хватает места в строке, переносить блок на следующую */
}
header {
  width: 100%;          /* Обязательно задаём ширину для шапки */
  height: 50px;
  background: cornflowerblue;
}
nav {
  background: darksalmon;
  width: 20%;           /* Задаём ширину навигационного меню */
}
main {
  height: 120px;
  background: khaki;
  width: 80%;           /* Задаём ширину контента */
}
footer {
  width: 100%;          /* Обязательно задаём ширину для футера */
  height: 50px;
  background: darkseagreen;
}</pre>
      <div data-run="lay2"></div>
      <p>
        Как мы видим, каким бы длинным ни был контент, под навигацией не образуется пробела, а так как больше нет флоатов, то перед футером можно вставить любой блок.К сожалению, таким способом мы не смогли решить последнюю проблему: как задать у меню фиксированную ширину, а ширина контента при этом была переменной?</p>
      <p>Больше о flex здесь:</p>
      <ul>
        <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox">Основные понятия Flexbox</a></li>
        <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/flex-wrap">flex-wrap</a></li>
        <li><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Aligning_Items_in_a_Flex_Container">align-items and justify-content</a></li>
      </ul>
    </section>
    <section>
      <h3>Grid</h3>
      <p>
        Самым современным способом вёрстки макетов на сегодняшний день является т.н. Grid layout. Грид позволяет выстраивать элементы внутри себя по заранее заданной сетке. Для начала разберём пример, а затем разберёмся подробнее, как это работает.</p>
      <pre data-lang="css" data-code="lay3">.main-container {
  margin: 0 auto;
  max-width: 800px;
  display: grid;                        /* Объявляем контейнер гридом */
  grid-template-rows: 50px 1fr 50px;    /* (1) Задаём строки*/
  grid-template-columns: 200px 1fr;     /* (2) Задаём колонки*/
  grid-template-areas: 'header header'  /* (3) Задаём названия областей*/
    'nav content' 
    'footer footer'; 
}
  header {
    grid-area: header;  /* Шапка займёт область с названием header */
    background: cornflowerblue;
}
nav {
  background: darksalmon;
  grid-area: nav;     /* Навигация займет область nav */
}
main {
  height: 120px;
  background: khaki;
  grid-area: content;  /* Контент займёт content */
}
footer {
  grid-area: footer;  /* Футер - footer */
  background: darkseagreen;
}</pre>
      <div data-run="lay3"></div>
      <p>Как можно заметить, мы избавились от всех негативных последствий. А теперь разберёмся подробнее, как это работает.</p>
      <ol>
        <li> <code>grid-template-rows: 50px 1fr 50px;</code>означает, что если смотреть на сайт по вертикали, то у нас образуются три строки: шапка, навигация с контентом, футер. 
          Высоту первой строки, шапки, установим равной 50px, высота второй строки нам неизвестна, а высота третьей, футера, тоже 50px.
        </li>
        <li> <code>grid-template-columns: 200px 1fr;</code>означает, что если смотреть на сайт по горизонтали, то образуются два столбца: слева навигация, справа контент.
          Ширину навигации установим равной 200px, а ширина контента нам неизвестна и она займёт всё доступное пространство.
        </li>
        <li>
           Итак, на этом этапе мы поняли, что у нас будет три строки и два столбца. Это и указываем далее:<code> grid-template-areas: 'header header'  'nav content'  'footer footer';</code>. Этот код создаёт три строки и два столбца, состоящие из именованных областей. Именовать эти области можно как угодно,
          их названия будут указаны в дочерних элементах в свойстве <code>grid-area</code>. Здесь мы видим, что шапка займёт две колонки; навигация - одну, левую колонку; контент - одну правую; футер - две колонки.
        </li>
      </ol>
      <p>Таким образом, мы получили идеальную сетку для нашего сайта. Подробнее о grid layout читать здесь:</p>
      <ul>
        <li><a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Grid_Layout">CSS Grid layout</a></li>
        <li><a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template">grid-template</a></li>
        <li> <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-area">grid-area</a></li>
      </ul>
    </section>
    <section>
      <h3>Calc</h3>
      <p>А теперь настало время удивляться. Вернёмся к примеру с флексом и добавим еще немного CSS:</p>
      <pre data-lang="css" data-code="lay4">nav {
  width: 200px;
}
main {
  width: calc(100% - 200px);
}</pre>
      <div data-run="lay4"></div>
      <p>Таким образом мы избавились от проблемы фиксированной ширины меню. Благодаря функции <code>calc()</code>, мы заставили ширину контента зависеть от ширины блока навигации. <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/calc">О calc() можно почитать здесь</a></p>
    </section>
    <section>
      <h3>Ещё один вариант вёрстки шаблона</h3>
      <p>На самом деле, есть еще один вариант. Он сложный и ненадёжный, но для общего развития, стоит упомянуть и его.</p>
      <pre data-lang="css" data-code="lay5">.main-container {
  margin: 0 auto;
  max-width: 800px;
  position: relative;
  padding: 50px 0 50px 200px;
  box-sizing: border-box;
}
header {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  height: 50px;
  background: cornflowerblue;
}
nav {
  background: darksalmon;
  position: absolute;
  top: 50px;
  bottom: 50px;
  left: 0;
  width: 200px;
  overflow-y: auto;
}
main {
  height: 120px;
  background: khaki;
  width: 100%;
}
footer {
  position: absolute;
  bottom: 0;
  right: 0;
  left: 0;
  height: 50px;
  background: darkseagreen;
}</pre>
      <div data-run="lay5"></div>
      <p>Что тут сделано?</p>
      <ol>
        <li>Основной контейнер спозиционирован относительно, чтобы абсолютно-спозиционированные элементы выстраивались внутри него.</li>
        <li>Шапка и футер прижимаются к верхней и нижней части контейнера.</li>
        <li>Навигация прижимается к левой части контейнера.</li>
        <li>Чтобы блоки не налезали друг на друга, с помощью внутренних отступов у основного контейнера, отделим контент от остальных блоков.</li>
        <li>Так как теперь высота блока навигации зависит от высоты контента, добавляем свойство<code>overflow</code>, чтобы при недостаточной высоте навигации, внутри неё появлялся скроллбар.</li>
      </ol>
    </section>
  </div>
</article>
<article id="grids">
  <div class="container">
    <h2>Сетки</h2>
    <p>
      Сетки нужны для того, чтобы правильно расположить содержимое на странице. Обычно, системы сеток состоят из контейнеров (container), рядов (row) и колонок (col). 
      Распространённой практикой являются двеннадцати-колоночные сетки. 
      Наиболее известная система сеток среди верстальщиков - это <a target="_blank" href="https://bootstrap-4.ru/docs/4.3.1/layout/grid/">Bootstrap Grid layout</a>
    </p>
    <p>В этой главе мы попробуем самостоятельно создать простую систему сеток.</p>
    <section>
      <h3>Float</h3>
      <p>Когда-то давно существовал лишь один более или менее хороший подход к проектированию сеток - сетки на флоатах.</p>
      <pre data-lang="html" data-code="grids-1">&lt;div class="container"&gt;
  &lt;div class="row"&gt;
    &lt;div class="col w8"&gt;
      &lt;span&gt;Ячейка w8&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="col w4"&gt;
      &lt;span&gt;Ячейка w4&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="row"&gt;
    &lt;div class="col w4"&gt;
      &lt;span&gt;Ячейка w4&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="col w4"&gt;
      &lt;span&gt;Ячейка w4&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="col w4"&gt;
      &lt;span&gt;Ячейка w4&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="row"&gt;
    &lt;div class="col w3"&gt;
      &lt;span&gt;Ячейка w3&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="col w3"&gt;
      &lt;span&gt;Ячейка &lt;br&gt; w3&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="col w3"&gt;
      &lt;span&gt;Ячейка w3&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="col w3"&gt;
      &lt;span&gt;Ячейка w3&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="row"&gt;
    &lt;div class="col w6"&gt;
      &lt;span&gt;Ячейка w6&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="col w6"&gt;
      &lt;span&gt;Ячейка w6&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
      <pre data-lang="css" data-code="grids-1">* {
  box-sizing: border-box;
}
.container {
  max-width: 800px;
  margin: 0 auto;
  padding: 0 5px;
}
.row {
  margin: 0 -5px 10px;
}
.row::after {
  content: '';
  display: block;
  clear: both;
}
.col {
  width: calc(100% / 12);
  float: left;
  padding: 0 5px;
}

.col.w1  { width: calc(100% / 12); }
.col.w2  { width: calc(100% * 2 / 12); }
.col.w3  { width: 25%; }
.col.w4  { width: calc(100% * 4 / 12); }
.col.w5  { width: calc(100% * 5 / 12); }
.col.w6  { width: 50%; }
.col.w7  { width: calc(100% * 7 / 12); }
.col.w8  { width: calc(100% * 8 / 12); }
.col.w9  { width: 75%; }
.col.w10 { width: calc(100% * 10 / 12); }
.col.w11 { width: calc(100% * 11 / 12); }
.col.w12 { width: 100%; }
</pre>
      <pre data-lang="css" data-code="grids-1,grids-2" hidden>.col span{
  display: block;
  background: lightblue;
  padding: 10px;
  height: 100%;
}
.col:nth-child(n+1) span{background: cornflowerblue}
.col:nth-child(n+2) span{background: darkseagreen}
.col:nth-child(n+3) span{background: khaki}
.col:nth-child(n+4) span{background: darksalmon}
</pre>
      <div data-run="grids-1"></div>
      <p>
        Как видим, всё не так уж и плохо. Лишь пара неприятных моментов: высоты колонок никак не зависят друг от друга, приходится подстраивать паддинги и 
        маргины, чтобы между колонками было расстояние, а ещё приходится писать много кода. 
      </p>
    </section>
    <section>
      <h3>Flex</h3>
      <p>Попробуем исправить предыдущий пример. </p>
      <pre data-lang="html" data-code="grids-2">&lt;div class="container"&gt;
  &lt;div class="row"&gt;
    &lt;div class="col w8"&gt;
      &lt;span&gt;Ячейка w8&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="col w4"&gt;
      &lt;span&gt;Ячейка w4&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="row"&gt;
    &lt;div class="col"&gt;
      &lt;span&gt;Ячейка&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="col"&gt;
      &lt;span&gt;Ячейка&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="col"&gt;
      &lt;span&gt;Ячейка&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="row"&gt;
    &lt;div class="col"&gt;
      &lt;span&gt;Ячейка&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="col"&gt;
      &lt;span&gt;Ячейка &lt;br&gt; вторая строка&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="col"&gt;
      &lt;span&gt;Ячейка&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="col"&gt;
      &lt;span&gt;Ячейка&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="row"&gt;
    &lt;div class="col"&gt;
      &lt;span&gt;Ячейка&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class="col"&gt;
      &lt;span&gt;Ячейка&lt;/span&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
      <pre data-lang="css" data-code="grids-2">* {
  box-sizing: border-box;
}
.container {
  max-width: 800px;
  margin: 0 auto;
  padding: 0 5px;
}
.row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -5px 10px;
}
.col {
  width: auto;
  max-width: 100%;
  flex-shrink: 0;
  flex-grow: 1;
  flex-basis: 0;
  padding: 0 5px;
}

.col.w1  { min-width: calc(100% / 12); flex-basis: calc(100% / 12)}
.col.w2  { min-width: calc(100% * 2 / 12); flex-basis:calc(100% * 2 / 12); }
.col.w3  { min-width: 25%; flex-basis: 25%; }
.col.w4  { min-width: calc(100% * 4 / 12); flex-basis: calc(100% * 4 / 12); }
.col.w5  { min-width: calc(100% * 5 / 12); flex-basis: calc(100% * 5 / 12); }
.col.w6  { min-width: 50%; flex-basis: 50%; }
.col.w7  { min-width: calc(100% * 7 / 12); flex-basis: calc(100% * 7 / 12); }
.col.w8  { min-width: calc(100% * 8 / 12); flex-basis: calc(100% * 8 / 12); }
.col.w9  { min-width: 75%; flex-basis: 75%; }
.col.w10 { min-width: calc(100% * 10 / 12); flex-basis: calc(100% * 10 / 12); }
.col.w11 { min-width: calc(100% * 11 / 12); flex-basis: calc(100% * 11 / 12); }
.col.w12 { min-width: 100%; flex-basis: 100%; }</pre>
      <div data-run="grids-2"></div>
      <p>
        Как видите, у этого метода есть свои плюсы. Когда нам нужны одинаковые колонки в ряду, нам не нужно указывать ширину этих колонок. И, хоть мы и избавились от хака с clear: both,
        кода меньше не стало. И снова подстраивать расстояния между блоками приходится не 
        без фокусов, хотя и высоты блоков теперь можно сделать зависимыми друг от друга. 
        Однако, этот способ действительно гораздо лучше предыдущего. 
      </p>
    </section>
    <section>
      <h3>Grid </h3>
      <p>Уже из названия этого способа понятно, что он придуман как раз для решения этой проблемы.</p>
      <p>Для начала, избавимся от строк. Они нам больше не нужны.</p>
      <pre data-lang="html" data-code="grids-3">&lt;div class="container"&gt;
  &lt;div class="grid g-2-1"&gt;
    &lt;div class="ceil"&gt;
      Ячейка
    &lt;/div&gt;
    &lt;div class="ceil"&gt;
      Ячейка
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="grid g-1-1-1"&gt;
    &lt;div class="ceil"&gt;
      Ячейка
    &lt;/div&gt;
    &lt;div class="ceil"&gt;
      Ячейка
    &lt;/div&gt;
    &lt;div class="ceil"&gt;
      Ячейка
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="grid g-1-1-1-1"&gt;
    &lt;div class="ceil"&gt;
      Ячейка
    &lt;/div&gt;
    &lt;div class="ceil"&gt;
      Ячейка &lt;br&gt; вторая строка
    &lt;/div&gt;
    &lt;div class="ceil"&gt;
      Ячейка
    &lt;/div&gt;
    &lt;div class="ceil"&gt;
      Ячейка
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="grid g-1-1"&gt;
    &lt;div class="ceil"&gt;
      Ячейка
    &lt;/div&gt;
    &lt;div class="ceil"&gt;
      Ячейка
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
      <pre data-lang="css" data-code="grids-3">.container {
  max-width: 800px;
  margin: 0 auto;
}        
.ceil {
  padding: 0 10px;
}
.grid {
  display: grid;
  gap: 10px;
  margin-bottom: 10px;
}

.grid.g-2-1 {
  grid-template-columns: 2fr 1fr;
}
.grid.g-1-1 {
  grid-template-columns: 1fr 1fr;
}
.grid.g-1-1-1 {
  grid-template-columns: repeat(3, 1fr);
}
.grid.g-1-1-1-1 {
  grid-template-columns: repeat(4, 1fr);
}</pre>
      <pre data-lang="css" data-code="grids-3,grids-4" hidden>.ceil {
  background: lightblue;
  padding-top: 10px !important;
  padding-bottom: 10px !important;
}
.ceil:nth-child(4n+1){background: cornflowerblue}
.ceil:nth-child(4n+2){background: darkseagreen}
.ceil:nth-child(4n+3){background: khaki}
.ceil:nth-child(4n+4){background: darksalmon}</pre>
      <div data-run="grids-3"></div>
      <p>
        Это совершенно иной подход к организации сеток. Как видите, здесь уже нет проблем с расстояниями между колонками, благодаря свойству <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/CSS/gap">gap</a>, кроме того, если вам нужна ровная сетка, кода станет гораздо меньше:</p>
      <pre data-lang="html" data-code="grids-4">&lt;div class="container"&gt;
  &lt;div class="ceil"&gt;
    Ячейка
  &lt;/div&gt;
  &lt;div class="ceil"&gt;
    Ячейка
  &lt;/div&gt;
  &lt;div class="ceil"&gt;
    Ячейка &lt;br&gt; вторая строка
  &lt;/div&gt;
  &lt;div class="ceil"&gt;
    Ячейка
  &lt;/div&gt;
  &lt;div class="ceil"&gt;
    Ячейка
  &lt;/div&gt;
  &lt;div class="ceil"&gt;
    Ячейка
  &lt;/div&gt;
  &lt;div class="ceil"&gt;
    Ячейка
  &lt;/div&gt;
  &lt;div class="ceil"&gt;
    Ячейка
  &lt;/div&gt;
  &lt;div class="ceil"&gt;
    Ячейка
  &lt;/div&gt;
&lt;/div&gt;
</pre>
      <pre data-lang="css" data-code="grids-4">.container {
  max-width: 800px;
  margin: 0 auto;
  display: grid;
  gap: 10px;
  grid-template-columns: repeat(3, 1fr);
}
.ceil {
  padding: 0 10px;
}</pre>
      <div data-run="grids-4"></div>
      <p>Теперь нам не обязательно иметь строки, а сам грид может быть совмещён с контейнером.</p>
      <p>Поэкспериментировать с этим примером можно здесь:</p><a class="codepen button" data-id="ExYLLqj" data-height="500">Запустить пример</a>
      <p>Кроме того, с помощью CSS Grid можно создавать вот такие необычные сетки:</p><a class="codepen button" data-id="eYOrKJY" data-height="500" data-default-tab="result">Запустить пример</a>
    </section>
  </div>
</article>
<article id="tooltip">
  <div class="container">
    <h2>Вёрстка тултипов</h2>
    <p>
      HTML имеет свои встроенные тултипы, но часто их дизайн не соответствует требованиям стиля макета. Наведите мышь на следующее предложение, чтобы понять, что такое тултип и как он выглядит по умолчанию. <span title="Тултип" style="border-bottom: 1px dotted black">Это предложение имеет тултип.</span> Сейчас мы научимся стилизовать тултипы. Для начала, нужно понять, что стандартный тултип - это своеобразное описание для элемента.</p>
    <p>Самый простой вид тултипа, который мы здесь будем рассматривать, не требует от HTML практически ничего. Мы будем использовать атрибут <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-label_attribute">aria-label</a>, который служит для описания элементов скринридерам (в основном, для людей с нарушениями зрения). </p>
    <p>Для того, чтобы через CSS "захватить" значение атрибута, необходимо использовать свойство <a target="_blank" href="http://htmlbook.ru/css/content">content</a>, использующееся с псевдоэлементами <a target="_blank" href="http://htmlbook.ru/css/before">::before</a> и <a target="_blank" href="http://htmlbook.ru/css/after">::after</a>.</p>
    <section>
      <h3>Итак, рассмотрим код:</h3>
      <pre data-lang="css" data-code="tooltip-1">.tooltip {
  position: relative; /* Элемент должен быть спозиционирован не статично, чтобы внутри него можно было разместить абсолютно-спозиционированный элемент */
}
.tooltip:hover::after {
  content: attr(aria-label); /* Захватываем атрибут aria-label и отображаем его в ::after псевдоэлементе */

  position: absolute; /* Позиционируем псевдоэлемент абсолютно */
  bottom: 100%;
  left: 0;

  background: rgba(0,0,0,.5);
  color: white;
  border-radius: 4px;
  padding: 8px 16px;
  font-size: 12px;
  cursor: default;
}

.like-button {
  /* Какие-то стили для кнопки */
}
</pre>
      <pre data-lang="css" data-code="tooltip-1,tooltip-2" hidden>.like-button {
  position: relative;
  background: none;
  border: none;
  padding: 0;
  font-size: 24px;
  color: tomato;
  margin: 40px 0;
  cursor: pointer;
}
.like-button:hover {
  color: darkred;
}
a {
  color: white;
  font-size: inherit;
}
a:hover {
  text-decoration: none;
}
@media print {
  .like-button.tooltip::after {
    content: attr(aria-label);
    position: absolute;
    bottom: 100%;
    left: 0;
    background: rgba(0,0,0,.5);
    color: white;
    border-radius: 4px;
    padding: 8px 16px;
    font-size: 12px;
    cursor: default;
  }
  .like-button .tooltip {
    display: inline-block !important;
  }
}
</pre>
      <pre data-lang="html" data-code="tooltip-1">&lt;button class="like-button tooltip" aria-label="Like"&gt;❤&lt;/button&gt;
</pre>
      <p>Наведи на сердечко, чтобы увидеть тултип</p>
      <div data-run="tooltip-1"></div>
    </section>
    <section>
      <h3>Тултип в виде HTML-элемента</h3>
      <p>
        К сожалению, рассмотренный выше тултип не идеален. Что делать, если внутри него нужно разместить ссылку? А многострочный текст? Да, бывают и такие задачи. Чтобы решить эту задачу, нам придётся использовать тултип в виде HTML-элемента.</p>
      <pre data-lang="css" data-code="tooltip-2">.has-tooltip {
  position: relative;
}
.has-tooltip:hover .tooltip {
  display: inline-block; /* Отображаем тултип только если навели мышью на элемент, его содержащий */
}

.tooltip {
  display: none; /* Скрываем тултип по умолчанию */

  position: absolute; 
  bottom: 100%;
  left: 0;

  min-width: 350px;
  text-align: left;
  background: rgba(0,0,0,.5);
  color: white;
  border-radius: 4px;
  padding: 8px 16px;
  font-size: 12px;
  margin-bottom: 8px;
  cursor: default;
}
.tooltip::after {
  /* Это уголок */
  content: '';
  position: absolute;
  top: 100%;
  left: 4px;
  border: 8px solid transparent;
  border-top-color: rgba(0,0,0,.5);
}
</pre>
      <pre data-lang="html" data-code="tooltip-2">&lt;button class="like-button has-tooltip" aria-label="Like"&gt;
  ❤
  &lt;span class="tooltip"&gt;
    А здесь мы уже можем размещать различную информацию, 
    &lt;br&gt;
    в том числе многострочный текст и даже
    &lt;a&gt;ссылки&lt;/a&gt;
  &lt;/span&gt;
&lt;/button&gt;
</pre>
      <div data-run="tooltip-2"></div>
      <p>В примере показано не совсем корректное скрытие тултипа. Рекомендую использовать <a href="https://allyjs.io/tutorials/hiding-elements.html#how-to-hide-elements-visually" target="_blank">.visually-hidden</a>.</p>
      <p>
        Существует еще множество способов сделать тултип, но многие из них подразумевают использование JavaScript, а эта книга не о нём. На мой взгляд, то, что можно сделать без JavaScript, нужно делать без JavaScript. Конечно, и из этого правила есть исключения.</p>
    </section>
  </div>
</article>
<article id="dropdown">
  <div class="container">
    <h2>Выпадающее меню и дропдауны</h2>
    <p>Пользуясь интернетом, вы наверняка уже видели выпадающее меню. Это когда наводишь мышью на элемент меню и появляется подменю.</p>
    <p>Сразу же перейдём к вёрстке. HTML предельно прост: есть меню, состоящее из четырёх элементов, а во втором элементе, помимо ссылки, есть вложенное меню.</p>
    <pre data-lang="html" data-code="dropdown-menu">&lt;menu&gt;
  &lt;li&gt;
    &lt;a&gt;Магазины&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a&gt;Покупателям&lt;/a&gt;
    &lt;menu class="dropdown"&gt;
      &lt;li&gt;
        &lt;a&gt;Бонусная программа&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a&gt;Подарочные карты&lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a&gt;Доставка&lt;/a&gt;
      &lt;/li&gt;
    &lt;/menu&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a&gt;Юридическим лицам&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;a&gt;Контакты&lt;/a&gt;
  &lt;/li&gt;
&lt;/menu&gt;
</pre>
    <p>
      CSS тоже не слишком сложный. Фактически, все стили вертятся вокруг оформления. Единственное - применен "магический" селектор. На самом деле, никакой магии здесь нет. <code>menu li:hover .dropdown</code>означает, что при наведении курсора мыши (<code>:hover</code>), на элемент меню (<code>menu li</code>), дропдаун (<code>.dropdown</code>) получит некоторые стили, в данном случае, <code>display: block</code>.</p>
    <pre data-lang="css" data-code="dropdown-menu">* {
  box-sizing: border-box;
}
menu {
  list-style: none;
  padding: 0;
  margin: 0 auto 100px;
  max-width: 800px;
  display: flex;
}
menu li {
  display: block;
  position: relative;
  width: 25%;
}
menu li a {
  padding: 8px 16px;
  background: lightblue;
  display: inline-block;
  width: 100%;
  text-decoration: none;
  color: black;
  text-align: center;
}
menu li a:hover { 
  background: teal;
  color: white;
}
menu li:hover .dropdown { /* Магия здесь */
  display: block;
}

.dropdown {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  padding: 0;
  margin: 0;
  min-width: 100%;
  list-style: none;
}
.dropdown li {
  display: block;
  width: auto;
}
.dropdown li a {
  text-align: left;
}

      <pre data-lang="css" data-code="dropdown,dropdown-menu" hidden>@media print {
  .dropdown {
    display: block !important;
  }
  menu {
    margin-bottom: 250px;
  }
}</pre></pre>
    <p>Результат представлен ниже. Попробуйте навести мышью на элементы меню.</p>
    <div data-run="dropdown-menu"></div>
    <p>Похожим способом можно сделать и дропдаун для кнопки</p>
    <pre data-lang="html" data-code="dropdown">&lt;button&gt;О нас
  &lt;ul class="dropdown"&gt;
    &lt;li&gt;&lt;a&gt;О компании прессе&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a&gt;Юридическая информация&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a&gt;Контактная информация&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/button&gt;
</pre>
    <pre data-lang="css" data-code="dropdown">button {
  background: white;
  border: 1px solid gray;
  border-radius: 4px;
  padding: 8px 16px;
  position: relative;
  margin-bottom: 100px;
}
button:hover {
  background: lightblue;
}
*:hover &gt; .dropdown { /* при наведении на любой элемент, содержащий .dropdown ... */
  display: block;
}
.dropdown {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  padding: 16px;
  margin: 0;
  list-style: none;
  box-shadow: 0 0 5px 0 black;
  border-radius: 4px;
  background: white;
  min-width: 200px;
}
.dropdown li {
  display: block;
  margin-bottom: 8px;
  text-align: left;
}

</pre>
    <div data-run="dropdown"></div>
  </div>
</article>
<article id="custom-checkbox">
  <div class="container">
    <h2>Вёрстка чекбоксов</h2>
    <p>Вёрстка почти каждой формы предполагает изменение вида стандартных чекбоксов. Изначально, они выглядят вот так: 
      <input type="checkbox"> и редко когда вписываются в дизайн. Поэтому каждый верстальщик знает, как кастомизировать чекбоксы. Сейчас и мы научимся это делать.
    </p>
    <p>
      В кратце, наша задача - использовать label со скрытым внутри чекбоксом. Дело в том, что в HTML клик по
      label переадресует его на внутенний элемент input. Кроме того, label можно использовать с атрибутом for,
      значением которого выступает id элемента input, находящегося снаружи нашего label, но применения этой
      конструкции я нашел лишь пару раз в своей практике.
    </p>
    <p> <a href="http://htmlbook.ru/html/label" target="_blank">Немного подробнее о label можно почитать здесь</a></p>
    <p>В этом видео Вадим Макеев подробно рассказывает об этой технике вёрстки чекбокса: </p>
    <div class="youtube" data-video="E6kLaaQFctU"></div>
    <section>
      <h3>Пример:</h3>
      <div data-run="custom-checkbox"></div>
      <p>Код:</p>
      <pre data-lang="html" data-code="custom-checkbox">&lt;p&gt;
  &lt;label class="custom-checkbox"&gt;
    &lt;input class="visually-hidden" type="checkbox"&gt;&lt;span class="checker"&gt;&lt;/span&gt;Checkbox
  &lt;/label&gt;
  &lt;label class="custom-checkbox"&gt;
    &lt;input class="visually-hidden" type="checkbox" checked="checked"&gt;&lt;span class="checker"&gt;&lt;/span&gt;Checked
  &lt;/label&gt;
  &lt;label class="custom-checkbox"&gt;
    &lt;input class="visually-hidden" type="checkbox" disabled="disabled"&gt;&lt;span class="checker"&gt;&lt;/span&gt;Disabled
  &lt;/label&gt;
  &lt;label class="custom-checkbox"&gt;
    &lt;input class="visually-hidden" type="checkbox" checked="checked" disabled="disabled"&gt;&lt;span class="checker"&gt;&lt;/span&gt;Checked disabled
  &lt;/label&gt;
&lt;/p&gt;
</pre>
      <pre data-lang="css" data-code="custom-checkbox,custom-checkbox-gmail">.custom-checkbox {
  /* Контейнер должен быть релятивным, так как внутри него мы разместим два абсолютно спозиционированных элемента */
  position: relative;
  /* скрываем элементы, попадающие за границы label */
  overflow: hidden;
  /* По умолчанию, label - это строчный элемент. С высокой вероятностью, нам нужно будет добавлять вертикальный margin, поэтому сразу сделаем его строчно-блочным*/
  display: inline-block;
  /* Делаем так, чтобы чекбокс нельзя было выделить курсором, а только нажать */
  user-select: none;
  /* Я приверженец того, что все интерактивные элементы должны иметь cursor: pointer, поэтому задаём и его */
  cursor: pointer;
  /* Отодвигаем левую часть так, чтобы влез кастомный чекбокс*/
  padding: 0 1em 0 1.4em;
  /* Задаём минимальную высоту */
  min-height: 1em;
}

/* Задаем кастомную галочку для чекбокса и скрываем её по умолчанию */
.custom-checkbox .checker {
  position: absolute;
  margin-top: 0;
  /* Выдвигаем чекбокс левее так, чтобы он не наезжал на текст */
  margin-left: -1.2em;
  width: 1em;
  height: 1em;
  overflow: hidden;
  text-align: center;
  font-size: 1em;
  line-height: 1;
  border: 1px solid teal;
  border-radius: 3px;
  background-color: white;
  /* Делаем галочку прозрачной */
  color: transparent;
}

/* В псевдо-элементе допишем саму галочку */
.custom-checkbox .checker:after {
  content: '✓';
}

/* указываем селектор на наш конкретный инпут с типом чекбокс */
.custom-checkbox input[type='checkbox'] {
  /* Выводим стандартный чекбокс за границы label */
  position: absolute;
  right: 100%;
  top: 0;
}

/* Несколько сложноее CSS правило: когда чекбокс будет иметь атрибут checked, его сосед снизу (селектор +) с классом .checker, примет эти стили */
.custom-checkbox input[type='checkbox']:checked + .checker {
  /* Перекрашиваем фон чекбокса и галочку */
  background-color: teal;
  color: white;
}

/* Не все люди используют для просмотра веб-страниц мышь, а некоторые из них используют вообще только клавиатуру. Так вот, чтобы интерактивные элементы подсвечивались, когда фокус клавиатуры попадал на них, им нужно задать отдельные стили. */
/* Когда скрытый инпут окажется в фокусе, его сосед с классом .checker примет стили */
.custom-checkbox input[type='checkbox']:focus + .checker {
  box-shadow: 0 0 5px 0 teal;
}

/* Когда скрытый интуп нельзя изменить, его сосед с классом .checker примет стили */
.custom-checkbox input[type='checkbox']:disabled+.checker {
  background-color: #999;
  border-color: #999;
}

/* Этот класс позволяет правильно скрыть элемент с экрана так, чтобы он был доступен для скринридеров */
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  margin: -1px;
  border: 0;
  padding: 0;
  clip: rect(0 0 0 0);
  overflow: hidden;
}
</pre>
      <p>Подробнее о visually-hidden можно почитать здесь: <a href="https://allyjs.io/tutorials/hiding-elements.html#how-to-hide-elements-visually" target="_blank">How to hide elements visually</a></p>
    </section>
    <section>
      <h3>Задача</h3>
      <p>Сверстать чекбоксы как в gmail.</p>
      <pre data-lang="css" data-code="custom-checkbox-gmail" hidden>.sol4 {
  display: flex;
  align-items: center;
  flex-direction: column;
}

.sol4 .row {
  border-bottom: 1px solid lightgray;
  border-top: 1px solid lightgray;
  padding: 8px;
  margin-bottom: -1px;
  display: block;
  line-height: 1;
  background: white;
}

.sol4 .custom-checkbox {
  padding-right: 0;
  vertical-align: middle;
}

.sol4 .custom-checkbox .checker::after {
  display: none;
}

.sol4 .custom-checkbox input[type='checkbox']:focus + .checker {
  box-shadow: none;
}

.sol4 .custom-checkbox .checker {
  background-repeat: no-repeat;
  background-position: center center;
  border: none;
  opacity: 0.3;
}

.sol4 .custom-checkbox input[type='checkbox']:checked + .checker {
  background-color: transparent;
  opacity: 1;
}

.sol4 .custom-checkbox.default .checker {
  background-image: url('https://www.gstatic.com/images/icons/material/system/1x/check_box_outline_blank_black_20dp.png');
}

.sol4 .custom-checkbox.default input[type='checkbox']:checked + .checker {
  background-image: url('https://www.gstatic.com/images/icons/material/system/1x/check_box_black_20dp.png');
}

.sol4 .custom-checkbox.star .checker {
  background-image: url('https://www.gstatic.com/images/icons/material/system/1x/star_border_black_20dp.png');
}

.sol4 .custom-checkbox.star input[type='checkbox']:checked + .checker {
  background-image: url('https://www.gstatic.com/images/icons/material/system/1x/star_googyellow500_20dp.png');
}

.sol4 .custom-checkbox.label .checker {
  background-image: url('https://www.gstatic.com/images/icons/material/system/1x/label_important_outline_black_20dp.png');
}

.sol4 .custom-checkbox.label input[type='checkbox']:checked + .checker {
  background-image: url('https://www.gstatic.com/images/icons/material/system/1x/label_important_googyellow500_20dp.png');
}
</pre>
      <pre data-lang="html" data-code="custom-checkbox-gmail" hidden>&lt;div class="sol4"&gt;
  &lt;div class="row"&gt;
    &lt;label class="custom-checkbox default"&gt;
      &lt;input class="visually-hidden" type="checkbox"&gt;&lt;span class="checker"&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;label class="custom-checkbox star"&gt;
      &lt;input class="visually-hidden" type="checkbox"&gt;&lt;span class="checker"&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;label class="custom-checkbox label"&gt;
      &lt;input class="visually-hidden" type="checkbox"&gt;&lt;span class="checker"&gt;&lt;/span&gt;
    &lt;/label&gt;
  &lt;/div&gt;
  &lt;div class="row"&gt;
    &lt;label class="custom-checkbox default"&gt;
      &lt;input class="visually-hidden" type="checkbox" checked&gt;&lt;span class="checker"&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;label class="custom-checkbox star"&gt;
      &lt;input class="visually-hidden" type="checkbox" checked&gt;&lt;span class="checker"&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;label class="custom-checkbox label"&gt;
      &lt;input class="visually-hidden" type="checkbox" checked&gt;&lt;span class="checker"&gt;&lt;/span&gt;
    &lt;/label&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
      <div data-run="custom-checkbox-gmail"></div>
      <p>Картинки для чекбоксов взять отсюда:</p>
      <ul>
        <li><a target="_blank" href="https://www.gstatic.com/images/icons/material/system/1x/check_box_outline_blank_black_20dp.png">Unchecked checkbox</a></li>
        <li><a target="_blank" href="https://www.gstatic.com/images/icons/material/system/1x/check_box_black_20dp.png">Checked checkbox</a></li>
        <li><a target="_blank" href="https://www.gstatic.com/images/icons/material/system/1x/star_border_black_20dp.png">Unchecked star</a></li>
        <li><a target="_blank" href="https://www.gstatic.com/images/icons/material/system/1x/star_googyellow500_20dp.png">Checked star</a></li>
        <li><a target="_blank" href="https://www.gstatic.com/images/icons/material/system/1x/label_important_outline_black_20dp.png">Unchecked label</a></li>
        <li><a target="_blank" href="https://www.gstatic.com/images/icons/material/system/1x/label_important_googyellow500_20dp.png">Checked label</a></li>
      </ul>
    </section>
  </div>
</article>
<article id="do-u-know">
  <div class="container">
    <h2>Знаете ли вы?</h2>
    <p>В этой статье приведены нестандартные и неоднозначные решения тех или иных проблем, связанных с вёрсткой.</p>
    <section>
      <h3>Знаете ли вы, что картинки можно хранить прямо в css-файле?</h3>
      <p>
        Небольшие картинки, используемые, например, в свойстве background-image, можно хранить прямо в css. Лучше всего это работает с SVG-графикой. Для того, чтобы вставить картинку в css, нам придется воспользоваться <a target="_blank" href="http://yoksel.github.io/url-encoder/ru/">простеньким энкодером</a>, который, к тому же, сразу же сгенерирует код для вставки в css. </p>
      <p>Если же у вас растровая иконка и вы используете <a target="_blank" href="https://lesscss.ru/">LESS</a>, то обратите внимание на <a target="_blank" href="https://lesscss.ru/functions/#misc-functions-data-uri">функцию data-uri</a>, которая принимает в качестве параметра путь к файлу с картинкой, а скомпилированный css-файл уже будет содержать закодированную картинку. </p>
    </section>
  </div>
</article>
<article id="practice">
  <div class="container">
    <h2>Практика</h2>
    <p>
      Настало время практики. попробуем сверстать простенький сайт, который, возможно, послужит вам первым резюме. Сразу оговорюсь по поводу картинок &mdash; в этом примере используется генерация людей нейросетью, этих людей никогда не существовало. 
      Если вы увидите что-то необычное или пугающее, просто обновите страницу, и, возможно, в этот раз нейросеть сгенерирует что-то более человечное. <a target="_blank" href="https://pikabu.ru/story/yetogo_cheloveka_ne_sushchestvuet_6506553">Описание на русском.</a>
    </p>
    <p>
      Вы можете изменять размер вьюпорта (мобильный вид / планшетный / ноутбук / монитор), потянув за правый нижний угол или используя переключатели сверху. По итогу, должно получиться примерно так:</p>
    <button class="internal-code" data-id="practice" data-height="90vh">Запустить пример</button>
  </div>
  <div class="internal-code-frame" data-id="practice">
    <div class="switch">
      <button data-id="practice" data-width="320" data-height="480"><span class="icon icon-mobile"></span></button>
      <button data-id="practice" data-width="700" data-height="600"><span class="icon icon-tablet"></span></button>
      <button data-id="practice" data-width="1300" data-height="650"><span class="icon icon-laptop"></span></button>
      <button data-id="practice" data-width="1900" data-height="950"><span class="icon icon-tv"></span></button>
    </div>
    <iframe src="./assets/practice/index.html"></iframe>
  </div>
  <section class="container">
    <h3>Разметка</h3>
    <p>Итак, приступим к вёрстке. Первым делом необходимо создать HTML-разметку. И сразу же подключим необходимые нам шрифты с <a target="_blank" href="https://fonts.google.com/">Google Fonts</a>. Мы будем использовать шрифт Open Sans. Кроме того, мы будем использовать иконки из пака <a target="_blank" href="https://fontawesome.com/">Font awesome</a>. Ну и сразу же создадим и подключим файл стилей. Назовём его, к примеру, <code>style.css </code>.</p>
    <pre data-lang="html">&lt;!DOCTYPE html&gt;
&lt;html lang="ru"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;Портфолио&lt;/title&gt;
    &lt;link rel="stylesheet" href="styles.css" /&gt;

    &lt;link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600&display=swap&subset=cyrillic" /&gt;
    &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.2/css/all.min.css" /&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;/body&gt;
&lt;/html&gt;
</pre>
    <p>Возможно, у вас возникли некоторые вопросы по нашей отправной точке. Постараюсь ответить на них последовательно. <code>&lt;html lang="ru"&gt;</code>в этой строке мы указываем язык страницы.<code>&lt;meta charset="UTF-8" /&gt;</code>означает, что кодировка страницы <a target="_blank" href="https://ru.wikipedia.org/wiki/UTF-8">UTF-8</a>.<code>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;</code>указывает, что сайт является адаптивным и самостоятельно подстроится под дисплей любого размера.</p>
    <p>
      Сразу подумаем, как должен выглядеть будущий сайт как на мобильных устройствах, так и на устройствах с большим дисплеем. Судя по макету, максимальная ширина сайта &mdash; 1200px, а если дисплей шире, то сайт выстраивается посередине. 
      Самый простой способ сделать так &mdash; использовать какой-то внешний контейнер. Внутри этого контейнера будет блок с краткой информацией 
      о человеке и блок с основным контентом. 
    </p>
    <pre data-lang="html">&lt;body&gt;
  &lt;main class="container"&gt;
    &lt;div class="info"&gt;...&lt;/div&gt;
    &lt;div class="content"&gt;...&lt;/div&gt;
  &lt;/main&gt;
&lt;/body&gt;
</pre>
    <p>Теперь посмотрим, что у нас есть в блоке с информацией (.info). Там есть фото, его имя, и три пары заголовок-контент. Попробуем это воссоздать.</p>
    <pre data-lang="html">&lt;div class="info"&gt;
  &lt;div class="photo"&gt;
    &lt;img ... /&gt;
  &lt;/div&gt;
  &lt;h1&gt;...&lt;/h1&gt;
  &lt;section&gt;
    &lt;h2&gt;...&lt;/h2&gt;
    ...
  &lt;/section&gt;
  &lt;section&gt;
    &lt;h2&gt;...&lt;/h2&gt;
    ...
  &lt;/section&gt;
  &lt;section&gt;
    &lt;h2&gt;...&lt;/h2&gt;
    ...
  &lt;/section&gt;
&lt;/div&gt;
</pre>
    <p>Блок с основным контентом представляет собой четыре пары заголовок-список. Так и напишем в коде:</p>
    <pre data-lang="html">&lt;div class="content"&gt;
  &lt;section&gt;
    &lt;h2&gt;...&lt;/h2&gt;
    &lt;ul&gt;...&lt;/ul&gt;
  &lt;/section&gt;
  &lt;section&gt;
    &lt;h2&gt;...&lt;/h2&gt;
    &lt;ul&gt;...&lt;/ul&gt;
  &lt;/section&gt;
  &lt;section&gt;
    &lt;h2&gt;...&lt;/h2&gt;
    &lt;ul&gt;...&lt;/ul&gt;
  &lt;/section&gt;
  &lt;section&gt;
    &lt;h2&gt;...&lt;/h2&gt;
    &lt;ul&gt;...&lt;/ul&gt;
  &lt;/section&gt;
&lt;/div&gt;
</pre>
  </section>
  <section class="container">
    <h3>Начальная стилизация</h3>
    <p>
      Приступим, наконец, к стилям. Прежде всего, нужно определиться с цветами, шрифтами и прочим. Используем CSS-переменные и занесём туда все цвета макета, примем border-box в качестве правила хорошего тона (об этом читай в статье <a href="#box-sizing">Блочная модель и box-sizing</a>), установим для странички основным шрифтом Open Sans, кегль шрифта &mdash; 16px (берём за основу кегль основного текста в макете), цвет шрифта сразу же установим
      согласно цвету основного текста в макете. Также обнулим значение margin по умолчанию для body.
    </p>
    <pre data-lang="css">:root {
  --back: #404042;
  --accent: #e61d31;
  --middle: #bbb;
  --light: #f2f2f2;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: 'Open Sans', sans-serif;
  font-size: 16px;
  color: var(--back);
} 
</pre>
    <p>Как мы и говорили раньше, максимальный размер контейнера &mdash; 1200px. Блоку с информацией присвоим тёмный фон, согласно макету, светлый цвет текста, внутренний отступ (можете подобрать любое значение, лишь бы потом не забыть сделать как по макету). Блоку с основным контентом тоже присвоим какой-то внутренний отступ и белый фон.</p>
    <pre data-lang="css">.container {
  max-width: 1200px;
}

.info {
  background-color: var(--back);
  color: var(--light);
  padding: 1rem;
}

.content {
  background-color: white;
  padding: 1rem;
}
</pre>
    <p>И сразу же зададим стили для абзацев и ссылок:</p>
    <pre data-lang="css">p {
  font-size: 1rem;
  margin: 0 0 0.5em;
}

a {
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

a .fab,
a .fas {
  margin-right: 0.5em;
}
</pre>
  </section>
  <section class="container">
    <h3>Вёрстка блоков</h3>
    <p>
      Существует два основных подхода к вёрстке адаптивных (подстраивающихся под устройство) сайтов: mobile-first и desktop-first. Первый считается общепризнанным стандартом, так как позволяет, теоретически, упростить вычисление CSS для мобильных устройств. Дело в том, что мобильные телефоны считаются более слабыми по сравнению с компьютерами. В случае, когда мы используем подход mobile-first, сайт изначально выглядит так, как нужно мобильным устройствам, а если ширина экрана это позволяет, подключает дополнительные CSS-правила, позволяющие расположить элементы, используя большую ширину экрана, нежели у телефона. 
      И так, постепенно наращивая количество правил, включающихся по мере роста ширины экрана, раскладка становится подходящей для широких экранов компьютера. В подходе desktop-first происходит наоборот &mdash; сначала сайт ведет себя как сайт для полноценных компьютеров, а если ширины экрана недостаточно, подключает стили, изменяющие раскладку элементов на раскладку, подходящую для мобильных устройств. 
      От этой дополнительной вычислительной нагрузки на мобильных устройствах принято отказываться по двум причинам:
    </p>
    <ol>
      <li>как было сказано выше, мобильные устройства не так производительны;</li>
      <li>более половины пользователей интернета используют, в первую очередь, мобильные устройства.</li>
    </ol>
    <p>Именно поэтому мы будем сначала верстать под мобильные устройства, а затем постепенно увеличивать экран.</p>
    <h4>Блок с информацией</h4>
    <p>Как видно на макете, цвета ссылок, а так же толщина шрифта ссылок и абзацев в блоке с тёмным фоном отличаются от этих параметров в блоке с основным контентом. Добавим для этого дополнительные стили:</p>
    <pre data-lang="css">.info a {
  color: var(--light);
  font-weight: 300;
}

.info h2 {
  font-weight: 300;
}
</pre>
    <h4>Фото профиля</h4>
    <p>Приступим к вёрстке отдельных блоков. Как было сказано выше, автор использует фотографии несуществующих людей, сгенерированные нейросетью. Ссылку на сгенерированную фотографию можно увидеть в коде. Обязательно указываем атрибут alt с описанием, что это за изображение.</p>
    <pre data-lang="html">&lt;div class="info"&gt;
  &lt;div class="photo"&gt;
    &lt;img src="https://thispersondoesnotexist.com/image" alt="Фото профиля" /&gt;
  &lt;/div&gt;
  ...
&lt;/div&gt;</pre>
    <pre data-lang="css">.photo {
  padding: 1rem;
}

.photo img {
  width: 100%;
  display: block;
  border-radius: 50%;
  filter: grayscale(1) contrast(1.2);
}
</pre>
    <p>
      Здесь мы указываем просто оформляем блок с фото. Чтобы квадратное фото сделать круглым, нужно задать border-radius: 50%. Однако, если фото не будет квадратным, то рекомендую указать значение этого свойства в пикселях, дабы не получить овал. В этом проекте автор использует неподготовленные для сайта фотографии, поэтому было принято решение обработать их согласно специфике сайта. Для этого используется <a target="_blank" href="https://developer.mozilla.org/ru/docs/Web/CSS/filter">CSS Filter</a>. </p>
    <h4>Заголовок</h4>
    <p>Вёрстка этого блока довольно проста: имя человека и его позиция является заголовком первого уровня. Чтобы отделить перенести должность на другую строку, нужно вынести её в отдельный тег и использовать <code>display: block</code>. </p>
    <pre data-lang="html">&lt;h1&gt;
  Дэми Браун
  &lt;small&gt;Junior front-end developer&lt;/small&gt;
&lt;/h1&gt;</pre>
    <pre data-lang="css">h1 {
  font-size: 2rem;
  font-weight: 300;
  margin: 0 0 0.2em;
  line-height: 1;
  text-align: center;
  color: var(--accent);
  text-transform: uppercase;
}

h1 small {
  display: block;
  font-size: 1rem;
  color: white;
  font-weight: 300;
  padding: 1em 0;
}
</pre>
    <h4>Секция с контактной информацией</h4>
    <p>Эта секция состоит из заголовка и списка ссылок с иконками. Вёрстка так же предельно проста:</p>
    <pre data-lang="html">&lt;section class="contacts"&gt;
  &lt;h2&gt;Контакты&lt;/h2&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;a href="//linkedin.com" target="_blank" rel="noreferrer"&gt;
        &lt;i class="fab fa-linkedin" aria-hidden="true"&gt;&lt;/i&gt;
        LinkedIn
      &lt;/a&gt;
    &lt;/li&gt;
    ...
  &lt;/ul&gt;
&lt;/section&gt;</pre>
    <p>Задачей CSS является просто немного подвигать элементы и задать размеры иконкам:</p>
    <pre data-lang="css">.contacts .fab,
.contacts .fas {
  font-size: 1.5em;
  vertical-align: middle;
}

.contacts ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.contacts li {
  margin-bottom: 1.5em;
}

h2 {
  font-size: 1.5rem;
  padding: 0 0 0.7em;
  margin: 2.5em 0 1em;
  border-bottom: 2px solid var(--middle);
  text-transform: uppercase;
  font-weight: 600;
  position: relative;
}

h2::after {
  content: '';
  display: block;
  position: absolute;
  bottom: -2px;
  left: 0;
  width: 4rem;
  border-bottom: 0.6rem solid var(--accent);
}</pre>
    <h5>Заголовок</h5>
    <p>Заголовок второго уровня имеет необычный элемент красного цвета под собой. Он спозиционирован относительно заголовка и представляет собой красный прямоугольник, находящийся на той же высоте, что и border заголовка.</p>
    <h5>Пара слов о ссылках</h5>
    <p>Оформление ссылок &mdash; это важная задача, игнорировать которую ни в коем случае нельзя, ведь это косвенно влияет на приток клиентов. К примеру, если у нас будет указан номер телефона, по нажатию на который ничего не произойдёт, мало какой клиент начнёт переписывать его в свой телефон для вызова. </p>
    <p>
      Для оформления ссылок на сторонние ресурсы, необходимо добавлять два атрибута у ссылок: target и rel. Атрибут target позволяет управлять поведением открытия страницы по ссылке. К примеру, значение этого атрибута _blank откроет страницу в новой вкладке. Именно его и нужно использовать для указания ссылок на сторонние ресурсы.Кроме того, необходимо указывать атрибут rel со значением noreferrer или nofollow. Этот атрибут говорит поисковым машинам, что ссылка ведёт на сторонний ресурс, индексировать который нам не обязательно.</p>
    <p>Оформление номера телефона обязательно сопровождается ссылкой, атрибут href которой начинается с tel. Телефон указывается в международном формате. К примеру, </p>
    <pre data-lang="html">&lt;a href="tel:+12345678900" rel="noreferrer"&gt;
  +1(234) 567-89-00
&lt;/a&gt;</pre>
    <p>Чтобы оформить ссылку на почту, используйте этот формат:</p>
    <pre data-lang="html">&lt;a href="mailto:mail@gmail.com" rel="noreferrer"&gt;
  mail@gmail.com
&lt;/a&gt;</pre>
    <p>Также можно оформлять ссылки на чат, к примеру, в WhatsApp, Telegram или Viber:</p>
    <pre data-lang="html">&lt;a href="https://wa.me/1234567890" rel="noreferrer"&gt; WhatsApp (+1234567890)&lt;/a&gt;</pre>
    <pre data-lang="html">&lt;a href="tg://resolve?domain=YOUR_NICKNAME" rel="noreferrer"&gt; Telegram (@YOUR_NICKNAME)&lt;/a&gt;</pre>
    <pre data-lang="html">&lt;a href="viber://chat?number=1234567890" rel="noreferrer"&gt; Viber (+1234567890)&lt;/a&gt;
</pre>
    <h4>Секции навыков и знания языков</h4>
    <p>Эта секция представляет собой заголовок и пары название-освоение. Ничего сложного:</p>
    <pre data-lang="html">&lt;section class="skills"&gt;
  &lt;h2&gt;Навыки&lt;/h2&gt;

  &lt;figure class="skill"&gt;
    &lt;figcaption class="title"&gt;HTML&lt;/figcaption&gt;
    &lt;svg class="progress" aria-label="50%"&gt;
      &lt;rect class="bar" style="width: 50%"&gt;&lt;/rect&gt;
    &lt;/svg&gt;
  &lt;/figure&gt;

  ...
&lt;/section&gt;
</pre>
    <pre data-lang="css">.skills .skill {
  display: grid;
  grid-template-columns: 1fr 2fr;
  gap: 1rem;
  align-items: center;
  margin: 0 0 1em;
}

.skills .skill .title {
  font-weight: 300;
}

.progress {
  background-color: var(--middle);
  width: 100%;
  height: 4px;
}

.progress .bar {
  fill: var(--accent);
  height: 100%;
}
</pre>
    <p>Разберёмся подробнее. Каждая фигура <code>&lt;figure class="skill"&gt;</code>является гридом. Внутри находится название<code>&lt;figcaption class="title"&gt;</code>и сама фигура, в данном случае, являющаяся inline-svg:<code>&lt;svg class="progress"&gt;</code>. По умолчанию SVG имеем какой-то размер, поэтому мы устанавливаем его своим:</p>
    <pre data-lang="css">.progress {
  width: 100%;
  height: 4px;
}</pre>
    <p>А чтобы перекрасить сам столбик прогресса, мы должны воспользоваться свойством <code>fill</code>, так как SVG-элементы не имеют свойства <code>background-color</code>.</p>
  </section>
  <section class="container"> 
    <h3>Основной контент</h3>
    <p>В этой части практики мы поговорим о блоке с контентом. Он состоит из четырёх секций: опыт, образование, интересы и проекты.</p>
    <h4>Секции "Опыт" и "Образование"</h4>
    <p>В секции "Опыт", помимо заголовка, находится список мест работы. Элементы списка содержат позицию как сотрудника компании, даты начала и окончания трудового договора, название компании, достижения и обязанности сотрудника.</p>
    <p>Секция "Образование" представляет собой точно такую же вёрстку, но другую информацию: вместо позиции &mdash; получаемую учёную степень; вместо дат трудового договора &mdash; даты начала и конца обучения; вместо названия компании &mdash; название ВУЗа; вместо обязанностей &mdash; кратко о полученных знаниях.</p>
    <pre data-lang="html">&lt;div class="content"&gt;
  &lt;section&gt;
    &lt;h2&gt;Опыт&lt;/h2&gt;

    &lt;ul class="experience"&gt;
      &lt;li&gt;
        &lt;div class="short-info"&gt;
          &lt;div class="position"&gt;Junior front end developer&lt;/div&gt;
          &lt;div class="date-range"&gt;
            &lt;time&gt;Сентябрь 2019&lt;/time&gt;
            &mdash;
            &lt;time&gt;По настоящее время&lt;/time&gt;
          &lt;/div&gt;
          &lt;div class="company"&gt;ООО &laquo;Рога и копыта&raquo;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="responsibilities"&gt;
          &lt;p&gt;
            Lorem, ipsum dolor sit amet consectetur adipisicing elit. Deserunt minima temporibus ratione quae
            dolorem accusamus doloribus consectetur dolor in aut at vel repellat rerum praesentium voluptate
            libero, eveniet pariatur? Quos?
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      
      ...

    &lt;/ul&gt;
  &lt;/section&gt;

  &lt;section&gt;
    &lt;h2&gt;Образование&lt;/h2&gt;

    ...

  &lt;/section&gt;
  ...

&lt;/div&gt;
</pre>
    <pre data-lang="css">.experience li {
  display: block;
  margin-bottom: 2rem;
}

.experience .short-info {
  margin-bottom: 1rem;
}

.experience .position {
  font-weight: 600;
}

.experience .date-range time {
  font-size: 0.7rem;
}
</pre>
    <p>Надеюсь, этот блок не доставит вам больших проблем в понимании.</p>
    <h4>Интересы </h4>
    <p>Этот блок состоит из списка иконок. Как мы понимаем, для незрячих людей, использующих скринридер, иконки это ничто. Поэтому им необходимо задать описание. Кроме того стоит подумать о том, как объяснить человеку, что скрывается за иконкой футбольного мяча? Футбол? Спорт? Мяч? Что-то ещё? Убить двух зайцев нам поможет атрибут <code>title</code>. Посмотрим, как это будет выглядеть:</p>
    <pre data-lang="html">&lt;section&gt;
  &lt;h2&gt;Интересы&lt;/h2&gt;

  &lt;ul class="interests"&gt;
    &lt;li&gt;
      &lt;i class="fas fa-futbol" title="Спорт"&gt;&lt;/i&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;i class="fas fa-camera-retro" title="Фотография"&gt;&lt;/i&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;i class="fas fa-guitar" title="Музыка"&gt;&lt;/i&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;i class="fas fa-suitcase-rolling" title="Путешествия"&gt;&lt;/i&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/section&gt;
</pre>
    <pre data-lang="css">.interests {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-wrap: wrap;
  font-size: 3rem;
  opacity: 0.8;
}

.interests li {
  margin-right: 1rem;
}
</pre>
    <p>Простое оформление списка в одну строку и немного стилей для размещения иконок. </p>
    <h4>Секция "Проекты"</h4>
    <p>Последняя часть разметки &mdash; секция "Проекты". Она содержит заголовок и список проектов, представляющих собой иконку, заголовок проекта с ссылкой на страницу проекта и описание.</p>
    <pre data-lang="html">&lt;section&gt;
    &lt;h2&gt;Проекты&lt;/h2&gt;

    &lt;ul class="projects"&gt;
      &lt;li&gt;
        &lt;i class="fas fa-file-code" aria-hidden="true"&gt;&lt;/i&gt;
        &lt;h3&gt;
          &lt;a href="#"&gt;
            Проект
          &lt;/a&gt;
        &lt;/h3&gt;
        &lt;p&gt;Описание проекта&lt;/p&gt;
      &lt;/li&gt;
      
      ...

    &lt;/ul&gt;
  &lt;/section&gt;
</pre>
    <pre data-lang="css">h3 {
  font-size: 1.2rem;
  margin: 0 0 0.5em;
}

.projects {
  list-style: none;
  margin: 0;
  padding: 0;
}

.projects li {
  margin-bottom: 1em;
  position: relative;
  padding-left: 3em;
}

.projects a {
  color: var(--back);
}

.projects .fas {
  position: absolute;
  top: 0.2em;
  left: 0;
  font-size: 2.5em;
  opacity: 0.8;
}
</pre>
    <p>Так как название и описание проекта находится в отдельных тегах, для слабовидящих людей иконка не несёт никакой смысловой нагрузки, поэтому её можно скрыть атрибутом <code>aria-hidden="true"</code>. Для зрячих же людей, спозиционируем картинку относительно элемента списка, представляющего собой проект. Мы могли бы также воспользоваться и flex-контейнером. </p>
  </section>
  <section class="container">
    <h3>Адаптивность и отзывчивость</h3>
    <p>
      К этому моменту у нас уже есть полностью функционирующая мобильная версия проекта. Однако, на этом этапе, она выглядит хорошо только до размера экрана примерно в 500px. Нам нужно создать медиа-выражение, изменяющее расположение блоков при достижении ширины экрана 500px. 
      Всё, что должно произойти к этому моменту &mdash; <code>.info</code>должен оказаться в левой части экрана, а блок<code>.content</code>&mdash; в правой.
    </p>
    <p>Как мы помним, HTML выглядит так:</p>
    <pre data-lang="html">&lt;body&gt;
  &lt;main class="container"&gt;
    &lt;div class="info"&gt;...&lt;/div&gt;
    &lt;div class="content"&gt;...&lt;/div&gt;
  &lt;/main&gt;
&lt;/body&gt;</pre>
    <p>Чтобы эти блоки расположились рядом, нужно прочитать статью <a href="#layouts">Многоколоночные макеты </a>и использовать один из представленных там методов. Для примера, я использую гриды:</p>
    <pre data-lang="css">@media (min-width: 500px) {
  .container {
    display: grid;
    grid-template-columns: 220px 1fr;
  }
}</pre>
    <p>Этот код читать нужно так: если ширина экрана более 500 пикселей, то блок<code>.container</code>станет гридом с раскладкой<code>200px 1fr.</code></p>
    <p>Увеличим ширину экрана ещё. На отметке примерно в 700px мы снова увидим, что вёрстка выглядит не очень хорошо. Создадим ещё одно правило:</p>
    <pre data-lang="css">@media (min-width: 700px) {
  body {
    background: linear-gradient(135deg, rgba(240, 240, 240, 1) 50%, rgba(225, 225, 225, 1) 50%);
  }

  .container {
    grid-template-columns: 2fr 3fr;
  }

  .info,
  .content {
    padding: 3rem;
  }
}</pre>
    <p>При достижении ширины экрана в 700px, установим на фон страницы градиент, изменим раскладку грида блока <code>.container </code>и зададим большие отступы для его дочерних блоков.</p>
    <p>Последние две точки адаптивности посвятим блокам <code>.experience </code>и блоку<code>.container</code>.</p>
    <pre data-lang="css">@media (min-width: 900px) {
  .experience li {
    display: grid;
    grid-template-columns: 2fr 3fr;
    gap: 2rem;
  }
}

@media (min-width: 1200px) {
  .container {
    margin: 5vh auto;
    box-shadow: 30px 50px 40px 20px rgba(0, 0, 0, 0.3);
  }
}
</pre>
  </section>
  <section class="container">
    <h3>Заключение</h3>
    <p>
      Таким образом, нам удалось сверстать простенькую страничку, которая может стать вашим стартом и первым проектом в области Font end разработки.  </p>
  </section>
</article>
      </div>
    </main>
  <script type="text/javascript" src="script.5846590c5a56abd0e5ff.js"></script></body>
</html>